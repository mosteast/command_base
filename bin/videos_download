#!/bin/bash

# Initialize variables
CHANNEL_URL=""
PLAYLIST_URL=""
default_output_dir="~/Library/Mobile Documents/com~apple~CloudDocs/main/download/video/YouTube/%(uploader)s"
OUTPUT_DIR="$default_output_dir"
output_dir_provided=false
VIDEO_URLS=()
ONLY_AUDIO=false
ONLY_SUBTITLE=false
OVERWRITE=false
REFRESH=false
youtube_player_client="web,web_safari,web_embedded"
fallback_player_client="android"
debug_mode=false
quiet_mode=false
dry_run=false
script_version="1.0.1"

# Retry configuration
retry_attempt_limit=3
retry_delay_seconds=2

# Color codes for output readability
color_reset="\033[0m"
color_green="\033[32m"
color_yellow="\033[33m"
color_red="\033[31m"
color_blue="\033[34m"

log_info() {
    if [ "$quiet_mode" = true ]; then
        return 0
    fi
    printf "%b%s%b\n" "$color_blue" "$1" "$color_reset"
}
log_success() {
    if [ "$quiet_mode" = true ]; then
        return 0
    fi
    printf "%b%s%b\n" "$color_green" "$1" "$color_reset"
}
log_warn() { printf "%b%s%b\n" "$color_yellow" "$1" "$color_reset"; }
log_error() { printf "%b%s%b\n" "$color_red" "$1" "$color_reset" >&2; }
log_debug() {
    if [ "$debug_mode" != true ] || [ "$quiet_mode" = true ]; then
        return 0
    fi
    printf "%b%s%b\n" "$color_blue" "$1" "$color_reset"
}

log_step() { log_debug "Step: $*"; }
log_io() { log_debug "IO: $*"; }

format_command() {
    local formatted=""
    local arg
    for arg in "$@"; do
        formatted+=$(printf '%q ' "$arg")
    done
    printf "%s" "${formatted% }"
}

# Function to show usage
show_usage() {
    local script_name
    script_name=$(basename "$0")

    cat <<EOF
${color_blue}Usage:${color_reset}
  ${script_name} -c|--channel <url> [options] [-- yt-dlp options]
  ${script_name} -l|--list <url> [options] [-- yt-dlp options]
  ${script_name} <video_url1> [video_url2...] [output_directory] [-- yt-dlp options]

${color_blue}Description:${color_reset}
  Download videos with yt-dlp from YouTube, Bilibili, or Rumble channels, playlists, or
  individual video URLs. Additional yt-dlp options can be passed after "--".

${color_blue}Options:${color_reset}
  -h, --help              Show this help message and exit
  -v, --version           Show version number and exit
      --debug             Print verbose debug output (default: false)
      --quiet             Print only warnings and errors (default: false)
  -d, --dry-run           Print actions without executing (default: false)
  -c, --channel <url>     Download all videos from a channel (YouTube/Bilibili/Rumble)
  -l, --list <url>        Download all videos from a playlist
  -o, --output <dir>      Specify output directory
  -r, --retry-count <n>   Retry attempts when yt-dlp fails (default: ${retry_attempt_limit})
      --only-audio        Download only audio files (default: false)
      --only-subtitle     Download only subtitle files (default: false)
      --overwrite         Force overwrite existing files (default: false)
      --refresh           Clear cached archive for the provided URLs before downloading (default: false)
      --youtube-client    YouTube player clients for yt-dlp (comma-separated, default: ${youtube_player_client})
      --fallback-client   Fallback clients without cookies when formats are missing (default: ${fallback_player_client})
                         Use 'none' to disable fallback.
      --                 Pass additional options to yt-dlp

${color_blue}Examples:${color_reset}
  # Download a YouTube channel
  \$0 -c https://www.youtube.com/@user1

  # Download a Bilibili space
  \$0 -c https://space.bilibili.com/39449692

  # Download a Rumble channel
  \$0 -c https://rumble.com/c/m16

  # Download a playlist with extra yt-dlp options
  \$0 -l https://www.youtube.com/playlist?list=xxx -- --dateafter 20240101

  # Download multiple videos into a custom folder
  \$0 https://youtu.be/xxx https://youtu.be/yyy ~/Downloads/YouTube

${color_yellow}Note:${color_reset} Use exactly one input type (channel, playlist, or video URLs).
EOF
}

detect_platform() {
    local url="$1"
    if [[ "$url" == *"youtube.com"* || "$url" == *"youtu.be"* ]]; then
        printf "youtube"
        return 0
    fi
    if [[ "$url" == *"bilibili.com"* || "$url" == *"b23.tv"* ]]; then
        printf "bilibili"
        return 0
    fi
    if [[ "$url" == *"rumble.com"* ]]; then
        printf "rumble"
        return 0
    fi
    printf "generic"
}

resolve_default_output_dir() {
    local platform="$1"
    case "$platform" in
        youtube)
            printf "%s" "$default_output_dir"
            ;;
        bilibili)
            printf "%s" "${default_output_dir/YouTube/Bilibili}"
            ;;
        rumble)
            printf "%s" "${default_output_dir/YouTube/Rumble}"
            ;;
        *)
            printf "%s" "$default_output_dir"
            ;;
    esac
}

normalize_channel_url() {
    local url="$1"
    local platform="$2"
    local base
    local query

    case "$platform" in
        youtube)
            if [[ "$url" == *"@"* && "$url" != */videos && "$url" != */videos/ ]]; then
                url="${url%/}/videos"
            fi
            ;;
        bilibili)
            if [[ "$url" == *"space.bilibili.com"* ]]; then
                base="$url"
                query=""
                if [[ "$base" == *"?"* ]]; then
                    query="${base#*\?}"
                    base="${base%%\?*}"
                fi
                if [[ "$base" != */video && "$base" != */video/ ]]; then
                    base="${base%/}/video"
                fi
                if [ -n "$query" ]; then
                    url="${base}?${query}"
                else
                    url="$base"
                fi
            fi
            ;;
    esac

    printf "%s" "$url"
}

retry_command() {
    local description="$1"
    shift
    local attempt=1

    if [ "$dry_run" = true ]; then
        log_info "Dry-run: ${description}"
        log_info "Dry-run command: $(format_command "$@")"
        return 0
    fi

    while true; do
        if [ "$debug_mode" = true ] && [ "$quiet_mode" != true ]; then
            log_debug "Step: ${description} (attempt ${attempt})"
            log_debug "IO: $(format_command "$@")"
        fi
        if "$@"; then
            if [ $attempt -gt 1 ]; then
                log_success "${description} succeeded on attempt ${attempt}."
            else
                log_info "${description} completed successfully."
            fi
            return 0
        fi

        local exit_code=$?
        log_warn "${description} failed on attempt ${attempt} (exit code ${exit_code})."

        if (( attempt >= retry_attempt_limit )); then
            log_error "${description} failed after ${retry_attempt_limit} attempts (last exit code ${exit_code})."
            return "$exit_code"
        fi

        attempt=$((attempt + 1))
        log_info "Retrying ${description} (attempt ${attempt} of ${retry_attempt_limit}) after ${retry_delay_seconds}s..."
        sleep "$retry_delay_seconds"
    done
}

yt_dlp_last_format_error=false

yt_dlp_output_has_format_error() {
    local log_file="$1"
    log_io "read yt-dlp log file ${log_file}"
    grep -Eqi "Requested format is not available|Only images are available|No video formats found" "$log_file"
}

run_yt_dlp_with_log() {
    local log_file
    if [ "$dry_run" = true ]; then
        log_info "Dry-run: $(format_command "$@")"
        yt_dlp_last_format_error=false
        return 0
    fi

    log_io "create temp yt-dlp log file"
    if ! log_file=$(mktemp -t yt_dlp_log.XXXXXX); then
        log_warn "Unable to create temp log file; running yt-dlp without format detection."
        yt_dlp_last_format_error=false
        if [ "$debug_mode" = true ] && [ "$quiet_mode" != true ]; then
            log_debug "IO: $(format_command "$@")"
        fi
        "$@"
        return $?
    fi

    if [ "$debug_mode" = true ] && [ "$quiet_mode" != true ]; then
        log_debug "IO: $(format_command "$@")"
    fi
    "$@" 2>&1 | tee "$log_file"
    local exit_code=${PIPESTATUS[0]}

    if yt_dlp_output_has_format_error "$log_file"; then
        yt_dlp_last_format_error=true
        exit_code=1
    else
        yt_dlp_last_format_error=false
    fi

    log_io "remove temp yt-dlp log file ${log_file}"
    rm -f "$log_file"
    return "$exit_code"
}

run_video_yt_dlp() {
    local url="$1"
    local archive_file="$2"
    local output_dir="$3"
    local use_cookies="$4"
    local player_client="$5"

    local -a yt_dlp_args
    yt_dlp_args=(
        "${EMBED_SUBS_OPTS[@]}"
        -o "$output_dir/%(uploader)s - Videos/%(title)s.%(ext)s"
        -N 1
        "${FORMAT_OPTS[@]}"
        "${WRITE_SUBS_OPTS[@]}"
        --sub-langs "en,en-US,zh-Hans,zh-Hant,zh-CN,zh"
        --sleep-subtitles 1
        --continue
    )

    if [ "$OVERWRITE" != true ]; then
        yt_dlp_args+=(--download-archive "$archive_file" --no-overwrites)
    else
        yt_dlp_args+=(--force-overwrites)
    fi

    yt_dlp_args+=(
        --sleep-interval 1
        --max-sleep-interval 3
        --retries 10
        --file-access-retries 5
        --fragment-retries 5
        --exec after_move:"rm -f -- \"%(filepath)s.ytdl\""
    )

    if [ "$use_cookies" = true ]; then
        yt_dlp_args+=(--cookies-from-browser chrome)
    fi

    if [ -n "$player_client" ]; then
        yt_dlp_args+=(--extractor-args "youtube:player_client=${player_client}")
    fi

    if [ ${#match_filter_opts[@]} -gt 0 ]; then
        yt_dlp_args+=("${match_filter_opts[@]}")
    fi

    yt_dlp_args+=(
        --add-header "Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
        --add-header "Accept-Language:en-us,en;q=0.5"
        --add-header "Accept-Encoding:gzip, deflate"
        --add-header "Accept-Charset:ISO-8859-1,utf-8;q=0.7,*;q=0.7"
        --add-header "User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36"
        "${EXTRA_OPTS[@]}"
        "$url"
    )

    run_yt_dlp_with_log yt-dlp "${yt_dlp_args[@]}"
}

download_video_with_fallback() {
    local url="$1"
    local archive_file="$2"
    local output_dir="$3"
    local platform="$4"
    local use_cookies=false
    local player_client=""

    if [ "$platform" = "youtube" ]; then
        use_cookies=true
        player_client="$youtube_player_client"
    fi

    if run_video_yt_dlp "$url" "$archive_file" "$output_dir" "$use_cookies" "$player_client"; then
        return 0
    fi

    local primary_exit_code=$?
    if [ "$platform" = "youtube" ] && [ "$yt_dlp_last_format_error" = true ] && [ -n "$fallback_player_client" ]; then
        log_warn "Primary download failed due to missing formats; retrying without cookies using '${fallback_player_client}'."
        run_video_yt_dlp "$url" "$archive_file" "$output_dir" false "$fallback_player_client"
        return $?
    fi

    return "$primary_exit_code"
}

# Parse command line arguments
for arg in "$@"; do
    if [ "$arg" = "--" ]; then
        break
    fi
    case "$arg" in
        --debug)
            debug_mode=true
            ;;
        --quiet)
            quiet_mode=true
            ;;
    esac
done

log_step "Parse command line arguments"
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_usage
            exit 0
            ;;
        -v|--version)
            printf "%s\n" "$script_version"
            exit 0
            ;;
        --debug)
            debug_mode=true
            shift
            ;;
        --quiet)
            quiet_mode=true
            shift
            ;;
        -d|--dry-run)
            dry_run=true
            shift
            ;;
        -c|--channel)
            if [ -n "$2" ]; then
                CHANNEL_URL="$2"
                shift 2
            else
                log_error "Channel URL is required after -c|--channel option."
                show_usage
                exit 1
            fi
            ;;
        -l|--list)
            if [ -n "$2" ]; then
                PLAYLIST_URL="$2"
                shift 2
            else
                log_error "Playlist URL is required after -l|--list option."
                show_usage
                exit 1
            fi
            ;;
        -o|--output)
            if [ -n "$2" ]; then
                OUTPUT_DIR="$2"
                output_dir_provided=true
                shift 2
            else
                log_error "Output directory is required after -o|--output option."
                show_usage
                exit 1
            fi
            ;;
        --retry-count=*)
            retry_value="${1#*=}"
            if [[ "$retry_value" =~ ^[0-9]+$ ]] && (( retry_value > 0 )); then
                retry_attempt_limit="$retry_value"
                shift
            else
                log_error "Retry count must be a positive integer."
                exit 1
            fi
            ;;
        -r|--retry-count)
            if [ -n "$2" ]; then
                retry_value="$2"
                if [[ "$retry_value" =~ ^[0-9]+$ ]] && (( retry_value > 0 )); then
                    retry_attempt_limit="$retry_value"
                    shift 2
                else
                    log_error "Retry count must be a positive integer."
                    exit 1
                fi
            else
                log_error "Retry count value is required after -r|--retry-count option."
                exit 1
            fi
            ;;
        --only-audio)
            ONLY_AUDIO=true
            shift
            ;;
        --only-subtitle)
            ONLY_SUBTITLE=true
            shift
            ;;
        --overwrite)
            OVERWRITE=true
            shift
            ;;
        --refresh)
            REFRESH=true
            shift
            ;;
        --youtube-client=*)
            youtube_player_client="${1#*=}"
            if [ -z "$youtube_player_client" ]; then
                log_error "YouTube player client list cannot be empty."
                exit 1
            fi
            shift
            ;;
        --youtube-client)
            if [ -n "$2" ]; then
                youtube_player_client="$2"
                shift 2
            else
                log_error "YouTube player client list is required after --youtube-client option."
                exit 1
            fi
            ;;
        --fallback-client=*)
            fallback_player_client="${1#*=}"
            shift
            ;;
        --fallback-client)
            if [ -n "$2" ]; then
                fallback_player_client="$2"
                shift 2
            else
                log_error "Fallback client list is required after --fallback-client option."
                exit 1
            fi
            ;;
        --)
            shift
            break
            ;;
        -*)
            log_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
        *)
            # If it's the last argument and there are other video URLs, it *could* be an output directory
            if [[ $# -eq 1 && ${#VIDEO_URLS[@]} -gt 0 ]]; then
                # If the argument contains typical URL patterns, treat as a URL.
                if [[ "$1" == "http"* || "$1" == *".com"* || "$1" == *".be"* || "$1" == *"watch?v="* ]]; then
                    VIDEO_URLS+=("$1")
                else
                    OUTPUT_DIR="$1"
                    output_dir_provided=true
                fi
            else
                VIDEO_URLS+=("$1")
            fi
            shift
            ;;
    esac
done

log_step "Deduplicate video URLs"
if [ ${#VIDEO_URLS[@]} -gt 1 ]; then
    DEDUPED_VIDEO_URLS=()
    for candidate_url in "${VIDEO_URLS[@]}"; do
        if printf '%s\n' "${DEDUPED_VIDEO_URLS[@]}" | grep -Fxq -- "$candidate_url"; then
            log_warn "Skipping duplicate URL in argument list: '${candidate_url}'"
            continue
        fi
        DEDUPED_VIDEO_URLS+=("$candidate_url")
    done
    if [ ${#DEDUPED_VIDEO_URLS[@]} -lt ${#VIDEO_URLS[@]} ]; then
        log_info "Video URL list reduced from ${#VIDEO_URLS[@]} to ${#DEDUPED_VIDEO_URLS[@]} unique entries."
    fi
    VIDEO_URLS=("${DEDUPED_VIDEO_URLS[@]}")
fi

# Validate audio/subtitle options
log_step "Validate audio/subtitle options"
if [ "$ONLY_AUDIO" = true ] && [ "$ONLY_SUBTITLE" = true ]; then
    log_error "Cannot use both --only-audio and --only-subtitle options together."
    exit 1
fi

if [ "$fallback_player_client" = "none" ] || [ "$fallback_player_client" = "off" ]; then
    fallback_player_client=""
fi

# Count how many input types are provided
log_step "Validate input type"
INPUT_COUNT=0
[ -n "$CHANNEL_URL" ] && ((INPUT_COUNT++))
[ -n "$PLAYLIST_URL" ] && ((INPUT_COUNT++))
[ ${#VIDEO_URLS[@]} -gt 0 ] && ((INPUT_COUNT++))

# Validate input
if [ $INPUT_COUNT -eq 0 ]; then
    log_error "No input provided. Please provide one of:"
    echo "  - Channel URL (-c|--channel)"
    echo "  - Playlist URL (-l|--list)"
    echo "  - One or more video URLs"
    echo ""
    show_usage
    exit 1
elif [ $INPUT_COUNT -gt 1 ]; then
    log_error "Multiple input types provided. Please use only one of:"
    echo "  - Channel URL (-c|--channel)"
    echo "  - Playlist URL (-l|--list)"
    echo "  - One or more video URLs"
    echo ""
    log_info "Current inputs:"
    [ -n "$CHANNEL_URL" ] && log_info "  Channel URL: '$CHANNEL_URL'"
    [ -n "$PLAYLIST_URL" ] && log_info "  Playlist URL: '$PLAYLIST_URL'"
    [ ${#VIDEO_URLS[@]} -gt 0 ] && log_info "  Video URLs: '${VIDEO_URLS[*]}'"
    exit 1
fi

# All remaining arguments will be passed to yt-dlp
EXTRA_OPTS=("$@")

# Create download archive directory if it doesn't exist
log_step "Prepare download archive directory"
ARCHIVE_DIR="${HOME}/.yt-dlp/archives"
if [ "$dry_run" = true ]; then
    log_info "Dry-run: would ensure archive directory '${ARCHIVE_DIR}'."
else
    log_io "ensure archive directory ${ARCHIVE_DIR}"
    mkdir -p "$ARCHIVE_DIR"
fi

# Set format and additional options based on download type
log_step "Configure format options"
FORMAT_OPTS=()
EMBED_SUBS_OPTS=()
WRITE_SUBS_OPTS=()

if [ "$ONLY_AUDIO" = true ]; then
    FORMAT_OPTS=(-f ba)
elif [ "$ONLY_SUBTITLE" = true ]; then
    FORMAT_OPTS=(--skip-download)
    WRITE_SUBS_OPTS=(--write-subs --write-auto-subs)
else
    EMBED_SUBS_OPTS=(--embed-subs)
    WRITE_SUBS_OPTS=(--write-subs --write-auto-subs)
fi

youtube_extractor_args=()
if [ -n "$youtube_player_client" ]; then
    youtube_extractor_args=(--extractor-args "youtube:player_client=${youtube_player_client}")
fi

# Define match filter that allows Rumble videos to bypass subscription check
# For Rumble videos - no filter, for other extractors - check for subscription requirement
MATCH_FILTER="extractor!='Rumble' & extractor!='RumbleEmbed' & availability!='needs_subscription' | extractor='Rumble' | extractor='RumbleEmbed'"
match_filter_opts=()
if [ -n "$MATCH_FILTER" ]; then
    match_filter_opts=(--match-filter "$MATCH_FILTER")
fi

# Handle channel URL mode
if [ -n "$CHANNEL_URL" ]; then
    log_step "Channel download"
    channel_platform=$(detect_platform "$CHANNEL_URL")
    if [ "$output_dir_provided" != true ]; then
        OUTPUT_DIR=$(resolve_default_output_dir "$channel_platform")
    fi
    CHANNEL_URL=$(normalize_channel_url "$CHANNEL_URL" "$channel_platform")

    channel_output_template="$OUTPUT_DIR/%(playlist)s/%(n_entries+1-playlist_index)d.%(title)s.%(ext)s"
    channel_cookie_opts=()
    channel_extractor_opts=()
    if [ "$channel_platform" = "youtube" ]; then
        channel_cookie_opts=(--cookies-from-browser chrome)
        channel_extractor_opts=(--extractor-args youtubetab:skip=authcheck "${youtube_extractor_args[@]}")
    else
        channel_output_template="$OUTPUT_DIR/%(title)s.%(ext)s"
    fi

    # Generate a unique archive file name based on the channel URL
    ARCHIVE_FILE="${ARCHIVE_DIR}/$(echo "$CHANNEL_URL" | md5sum | cut -d' ' -f1).txt"

    if [ "$REFRESH" = true ]; then
        if [ -f "$ARCHIVE_FILE" ]; then
            log_info "Refresh requested; clearing archive cache at '$ARCHIVE_FILE'."
            if [ "$dry_run" = true ]; then
                log_info "Dry-run: would remove archive cache at '${ARCHIVE_FILE}'."
            else
                log_io "remove archive cache ${ARCHIVE_FILE}"
                rm -f "$ARCHIVE_FILE"
            fi
        else
            log_warn "Refresh requested but no archive cache found for '$CHANNEL_URL'."
        fi
    fi

    retry_command "Channel download: ${CHANNEL_URL}" yt-dlp \
        --playlist-reverse \
        "${EMBED_SUBS_OPTS[@]}" \
        -o "$channel_output_template" \
        "${channel_cookie_opts[@]}" \
        -N 1 \
        -i \
        "${FORMAT_OPTS[@]}" \
        "${WRITE_SUBS_OPTS[@]}" \
        --sub-langs "en,en-US,zh-Hans,zh-Hant,zh-CN,zh" \
        --sleep-subtitles 1 \
        --continue \
        $( [ "$OVERWRITE" != true ] && echo "--download-archive $ARCHIVE_FILE --no-overwrites" ) \
        $( [ "$OVERWRITE" = true ] && echo "--force-overwrites" ) \
        "${channel_extractor_opts[@]}" \
        --referer "$CHANNEL_URL" \
        --sleep-interval 1 \
        --max-sleep-interval 3 \
        --retries 10 \
        --file-access-retries 5 \
        --fragment-retries 5 \
        --exec after_move:"rm -f -- \"%(filepath)s.ytdl\"" \
        "${match_filter_opts[@]}" \
        --add-header "Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
        --add-header "Accept-Language:en-us,en;q=0.5" \
        --add-header "Accept-Encoding:gzip, deflate" \
        --add-header "Accept-Charset:ISO-8859-1,utf-8;q=0.7,*;q=0.7" \
        --add-header "User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36" \
        "${EXTRA_OPTS[@]}" \
        "$CHANNEL_URL"

    channel_status=$?
    exit "$channel_status"

# Handle playlist URL mode
elif [ -n "$PLAYLIST_URL" ]; then
    log_step "Playlist download"
    playlist_platform=$(detect_platform "$PLAYLIST_URL")
    if [ "$output_dir_provided" != true ]; then
        OUTPUT_DIR=$(resolve_default_output_dir "$playlist_platform")
    fi

    playlist_output_template="$OUTPUT_DIR/%(playlist)s/%(playlist_index)s.%(title)s.%(ext)s"
    playlist_cookie_opts=()
    playlist_extractor_opts=()
    if [ "$playlist_platform" = "youtube" ]; then
        playlist_cookie_opts=(--cookies-from-browser chrome)
        playlist_extractor_opts=("${youtube_extractor_args[@]}")
    else
        playlist_output_template="$OUTPUT_DIR/%(title)s.%(ext)s"
    fi

    # Generate a unique archive file name based on the playlist URL
    ARCHIVE_FILE="${ARCHIVE_DIR}/$(echo "$PLAYLIST_URL" | md5sum | cut -d' ' -f1).txt"

    if [ "$REFRESH" = true ]; then
        if [ -f "$ARCHIVE_FILE" ]; then
            log_info "Refresh requested; clearing archive cache at '$ARCHIVE_FILE'."
            if [ "$dry_run" = true ]; then
                log_info "Dry-run: would remove archive cache at '${ARCHIVE_FILE}'."
            else
                log_io "remove archive cache ${ARCHIVE_FILE}"
                rm -f "$ARCHIVE_FILE"
            fi
        else
            log_warn "Refresh requested but no archive cache found for '$PLAYLIST_URL'."
        fi
    fi

    retry_command "Playlist download: ${PLAYLIST_URL}" yt-dlp \
        --playlist-reverse \
        "${EMBED_SUBS_OPTS[@]}" \
        -o "$playlist_output_template" \
        "${playlist_cookie_opts[@]}" \
        -N 1 \
        -i \
        "${FORMAT_OPTS[@]}" \
        "${WRITE_SUBS_OPTS[@]}" \
        --sub-langs "en,en-US,en-GB,zh-Hans,zh-Hant,zh-CN,zh" \
        --sleep-subtitles 1 \
        --continue \
        $( [ "$OVERWRITE" != true ] && echo "--download-archive $ARCHIVE_FILE --no-overwrites" ) \
        $( [ "$OVERWRITE" = true ] && echo "--force-overwrites" ) \
        --yes-playlist \
        --sleep-interval 1 \
        --max-sleep-interval 3 \
        --retries 10 \
        --file-access-retries 5 \
        --fragment-retries 5 \
        --exec after_move:"rm -f -- \"%(filepath)s.ytdl\"" \
        "${playlist_extractor_opts[@]}" \
        "${match_filter_opts[@]}" \
        --add-header "Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
        --add-header "Accept-Language:en-us,en;q=0.5" \
        --add-header "Accept-Encoding:gzip, deflate" \
        --add-header "Accept-Charset:ISO-8859-1,utf-8;q=0.7,*;q=0.7" \
        --add-header "User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36" \
        "${EXTRA_OPTS[@]}" \
        "$PLAYLIST_URL"

    playlist_status=$?
    exit "$playlist_status"

# Handle individual video URLs mode
else
    log_step "Manual video download"
    overall_exit_code=0
    failed_video_urls=()
    expanded_output_dir="${OUTPUT_DIR/#\~/$HOME}"
    [ -z "$expanded_output_dir" ] && expanded_output_dir="manual_video_downloads"
    manual_archive_hash=$(printf "%s" "$expanded_output_dir" | md5sum | cut -d' ' -f1)
    manual_archive_file="${ARCHIVE_DIR}/manual_urls_${manual_archive_hash}.txt"

    if [ "$REFRESH" = true ]; then
        if [ -f "$manual_archive_file" ]; then
            log_info "Refresh requested; clearing archive cache at '${manual_archive_file}'."
            if [ "$dry_run" = true ]; then
                log_info "Dry-run: would remove archive cache at '${manual_archive_file}'."
            else
                log_io "remove archive cache ${manual_archive_file}"
                rm -f "$manual_archive_file"
            fi
        else
            log_warn "Refresh requested but no manual video archive found to clear."
        fi
    fi

    if [ "$OVERWRITE" != true ]; then
        if [ "$dry_run" = true ]; then
            log_info "Dry-run: would create archive cache at '${manual_archive_file}'."
        else
            log_io "create archive cache ${manual_archive_file}"
            touch "$manual_archive_file"
        fi
    fi

    for url in "${VIDEO_URLS[@]}"; do
        url_platform=$(detect_platform "$url")

        if retry_command "Video download: ${url}" download_video_with_fallback "$url" "$manual_archive_file" "$OUTPUT_DIR" "$url_platform"
        then
            :
        else
            download_status=$?
            log_error "Skipping ${url} after ${retry_attempt_limit} failed attempts."
            overall_exit_code=$download_status
            failed_video_urls+=("$url")
            continue
        fi
    done

    if [ ${#failed_video_urls[@]} -gt 0 ]; then
        log_warn "Failed videos after ${retry_attempt_limit} attempts:"
        for failed_url in "${failed_video_urls[@]}"; do
            log_warn "  - ${failed_url}"
        done
    fi

    exit "$overall_exit_code"
fi
