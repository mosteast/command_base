#!/bin/bash

# Initialize variables
CHANNEL_URL=""
PLAYLIST_URL=""
OUTPUT_DIR="~/Library/Mobile Documents/com~apple~CloudDocs/main/download/video/YouTube/%(uploader)s"
VIDEO_URLS=()
ONLY_AUDIO=false
ONLY_SUBTITLE=false
OVERWRITE=false
REFRESH=false
youtube_player_client="web,web_safari,web_embedded"
fallback_player_client="android"

# Retry configuration
retry_attempt_limit=3
retry_delay_seconds=2

# Color codes for output readability
color_reset="\033[0m"
color_green="\033[32m"
color_yellow="\033[33m"
color_red="\033[31m"
color_blue="\033[34m"

log_info() { printf "%b%s%b\n" "$color_blue" "$1" "$color_reset"; }
log_success() { printf "%b%s%b\n" "$color_green" "$1" "$color_reset"; }
log_warn() { printf "%b%s%b\n" "$color_yellow" "$1" "$color_reset"; }
log_error() { printf "%b%s%b\n" "$color_red" "$1" "$color_reset" >&2; }

# Function to show usage
show_usage() {
    local script_name
    script_name=$(basename "$0")

    printf "%bUsage:%b\n" "$color_blue" "$color_reset"
    printf "  1. Channel download:\n"
    printf "     %s -c|--channel <youtube_channel_url> [-o|--output <directory>]\n" "$script_name"
    printf "     Example: %s -c https://www.youtube.com/@user1\n" "$script_name"
    printf "\n"
    printf "  2. Playlist download:\n"
    printf "     %s -l|--list <youtube_playlist_url> [-o|--output <directory>]\n" "$script_name"
    printf "     Example: %s -l https://www.youtube.com/playlist?list=xxx\n" "$script_name"
    printf "\n"
    printf "  3. Video download:\n"
    printf "     %s <video_url1> [video_url2...] [output_directory]\n" "$script_name"
    printf "     Example: %s https://youtu.be/xxx https://youtu.be/yyy ~/Downloads/YouTube\n" "$script_name"
    printf "\n"
    printf "%bOptions:%b\n" "$color_blue" "$color_reset"
    printf "  -h, --help              Show this help message and exit\n"
    printf "  -c, --channel <url>     Download all videos from a YouTube channel\n"
    printf "  -l, --list <url>        Download all videos from a YouTube playlist\n"
    printf "  -o, --output <dir>      Specify output directory\n"
    printf "  -r, --retry-count <n>   Retry attempts when yt-dlp fails (default: %s)\n" "$retry_attempt_limit"
    printf "      --only-audio        Download only audio files\n"
    printf "      --only-subtitle     Download only subtitle files\n"
    printf "      --overwrite         Force overwrite existing files\n"
    printf "      --refresh           Clear cached archive for the provided URLs before downloading\n"
    printf "      --youtube-client    YouTube player clients for yt-dlp (comma-separated, default: %s)\n" "$youtube_player_client"
    printf "      --fallback-client   Fallback clients without cookies when formats are missing (default: %s)\n" "$fallback_player_client"
    printf "                         Use 'none' to disable fallback.\n"
    printf "      --                   Pass additional options to yt-dlp\n"
    printf "\n"
    printf "%bExamples:%b\n" "$color_blue" "$color_reset"
    printf "  %s -c https://www.youtube.com/@user1\n" "$script_name"
    printf "  %s -l https://www.youtube.com/playlist?list=xxx --retry-count 5\n" "$script_name"
    printf "  %s https://youtu.be/xxx ~/Downloads/YouTube\n" "$script_name"
    printf "\n"
    printf "%bNote:%b You must use exactly one input type (channel, playlist, or video URLs).\n" "$color_yellow" "$color_reset"
}

retry_command() {
    local description="$1"
    shift
    local attempt=1

    while true; do
        if "$@"; then
            if [ $attempt -gt 1 ]; then
                log_success "${description} succeeded on attempt ${attempt}."
            else
                log_info "${description} completed successfully."
            fi
            return 0
        fi

        local exit_code=$?
        log_warn "${description} failed on attempt ${attempt} (exit code ${exit_code})."

        if (( attempt >= retry_attempt_limit )); then
            log_error "${description} failed after ${retry_attempt_limit} attempts (last exit code ${exit_code})."
            return "$exit_code"
        fi

        attempt=$((attempt + 1))
        log_info "Retrying ${description} (attempt ${attempt} of ${retry_attempt_limit}) after ${retry_delay_seconds}s..."
        sleep "$retry_delay_seconds"
    done
}

yt_dlp_last_format_error=false

yt_dlp_output_has_format_error() {
    local log_file="$1"
    grep -Eqi "Requested format is not available|Only images are available|No video formats found" "$log_file"
}

run_yt_dlp_with_log() {
    local log_file
    if ! log_file=$(mktemp -t yt_dlp_log.XXXXXX); then
        log_warn "Unable to create temp log file; running yt-dlp without format detection."
        yt_dlp_last_format_error=false
        "$@"
        return $?
    fi

    "$@" 2>&1 | tee "$log_file"
    local exit_code=${PIPESTATUS[0]}

    if yt_dlp_output_has_format_error "$log_file"; then
        yt_dlp_last_format_error=true
        exit_code=1
    else
        yt_dlp_last_format_error=false
    fi

    rm -f "$log_file"
    return "$exit_code"
}

run_video_yt_dlp() {
    local url="$1"
    local archive_file="$2"
    local output_dir="$3"
    local use_cookies="$4"
    local player_client="$5"

    local -a yt_dlp_args
    yt_dlp_args=(
        "${EMBED_SUBS_OPTS[@]}"
        -o "$output_dir/%(uploader)s - Videos/%(title)s.%(ext)s"
        -N 1
        "${FORMAT_OPTS[@]}"
        "${WRITE_SUBS_OPTS[@]}"
        --sub-langs "en,en-US,zh-Hans,zh-Hant,zh-CN,zh"
        --sleep-subtitles 1
        --continue
    )

    if [ "$OVERWRITE" != true ]; then
        yt_dlp_args+=(--download-archive "$archive_file" --no-overwrites)
    else
        yt_dlp_args+=(--force-overwrites)
    fi

    yt_dlp_args+=(
        --sleep-interval 1
        --max-sleep-interval 3
        --retries 10
        --file-access-retries 5
        --fragment-retries 5
        --exec after_move:"rm -f -- \"%(filepath)s.ytdl\""
    )

    if [ "$use_cookies" = true ]; then
        yt_dlp_args+=(--cookies-from-browser chrome)
    fi

    if [ -n "$player_client" ]; then
        yt_dlp_args+=(--extractor-args "youtube:player_client=${player_client}")
    fi

    yt_dlp_args+=(
        --add-header "Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
        --add-header "Accept-Language:en-us,en;q=0.5"
        --add-header "Accept-Encoding:gzip, deflate"
        --add-header "Accept-Charset:ISO-8859-1,utf-8;q=0.7,*;q=0.7"
        --add-header "User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36"
        "${EXTRA_OPTS[@]}"
        "$url"
    )

    run_yt_dlp_with_log yt-dlp "${yt_dlp_args[@]}"
}

download_video_with_fallback() {
    local url="$1"
    local archive_file="$2"
    local output_dir="$3"

    if run_video_yt_dlp "$url" "$archive_file" "$output_dir" true "$youtube_player_client"; then
        return 0
    fi

    local primary_exit_code=$?
    if [ "$yt_dlp_last_format_error" = true ] && [ -n "$fallback_player_client" ]; then
        log_warn "Primary download failed due to missing formats; retrying without cookies using '${fallback_player_client}'."
        run_video_yt_dlp "$url" "$archive_file" "$output_dir" false "$fallback_player_client"
        return $?
    fi

    return "$primary_exit_code"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_usage
            exit 0
            ;;
        -c|--channel)
            if [ -n "$2" ]; then
                CHANNEL_URL="$2"
                shift 2
            else
                log_error "Channel URL is required after -c|--channel option."
                show_usage
                exit 1
            fi
            ;;
        -l|--list)
            if [ -n "$2" ]; then
                PLAYLIST_URL="$2"
                shift 2
            else
                log_error "Playlist URL is required after -l|--list option."
                show_usage
                exit 1
            fi
            ;;
        -o|--output)
            if [ -n "$2" ]; then
                OUTPUT_DIR="$2"
                shift 2
            else
                log_error "Output directory is required after -o|--output option."
                show_usage
                exit 1
            fi
            ;;
        --retry-count=*)
            retry_value="${1#*=}"
            if [[ "$retry_value" =~ ^[0-9]+$ ]] && (( retry_value > 0 )); then
                retry_attempt_limit="$retry_value"
                shift
            else
                log_error "Retry count must be a positive integer."
                exit 1
            fi
            ;;
        -r|--retry-count)
            if [ -n "$2" ]; then
                retry_value="$2"
                if [[ "$retry_value" =~ ^[0-9]+$ ]] && (( retry_value > 0 )); then
                    retry_attempt_limit="$retry_value"
                    shift 2
                else
                    log_error "Retry count must be a positive integer."
                    exit 1
                fi
            else
                log_error "Retry count value is required after -r|--retry-count option."
                exit 1
            fi
            ;;
        --only-audio)
            ONLY_AUDIO=true
            shift
            ;;
        --only-subtitle)
            ONLY_SUBTITLE=true
            shift
            ;;
        --overwrite)
            OVERWRITE=true
            shift
            ;;
        --refresh)
            REFRESH=true
            shift
            ;;
        --youtube-client=*)
            youtube_player_client="${1#*=}"
            if [ -z "$youtube_player_client" ]; then
                log_error "YouTube player client list cannot be empty."
                exit 1
            fi
            shift
            ;;
        --youtube-client)
            if [ -n "$2" ]; then
                youtube_player_client="$2"
                shift 2
            else
                log_error "YouTube player client list is required after --youtube-client option."
                exit 1
            fi
            ;;
        --fallback-client=*)
            fallback_player_client="${1#*=}"
            shift
            ;;
        --fallback-client)
            if [ -n "$2" ]; then
                fallback_player_client="$2"
                shift 2
            else
                log_error "Fallback client list is required after --fallback-client option."
                exit 1
            fi
            ;;
        --)
            shift
            break
            ;;
        -*)
            log_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
        *)
            # If it's the last argument and there are other video URLs, it *could* be an output directory
            if [[ $# -eq 1 && ${#VIDEO_URLS[@]} -gt 0 ]]; then
                # If the argument contains typical URL patterns, treat as a URL.
                if [[ "$1" == "http"* || "$1" == *".com"* || "$1" == *".be"* || "$1" == *"watch?v="* ]]; then
                    VIDEO_URLS+=("$1")
                else
                    OUTPUT_DIR="$1"
                fi
            else
                VIDEO_URLS+=("$1")
            fi
            shift
            ;;
    esac
done

# Remove exact duplicate video URLs to avoid redundant downloads in the same run
if [ ${#VIDEO_URLS[@]} -gt 1 ]; then
    DEDUPED_VIDEO_URLS=()
    for candidate_url in "${VIDEO_URLS[@]}"; do
        if printf '%s\n' "${DEDUPED_VIDEO_URLS[@]}" | grep -Fxq -- "$candidate_url"; then
            log_warn "Skipping duplicate URL in argument list: '${candidate_url}'"
            continue
        fi
        DEDUPED_VIDEO_URLS+=("$candidate_url")
    done
    if [ ${#DEDUPED_VIDEO_URLS[@]} -lt ${#VIDEO_URLS[@]} ]; then
        log_info "Video URL list reduced from ${#VIDEO_URLS[@]} to ${#DEDUPED_VIDEO_URLS[@]} unique entries."
    fi
    VIDEO_URLS=("${DEDUPED_VIDEO_URLS[@]}")
fi

# Validate audio/subtitle options
if [ "$ONLY_AUDIO" = true ] && [ "$ONLY_SUBTITLE" = true ]; then
    log_error "Cannot use both --only-audio and --only-subtitle options together."
    exit 1
fi

if [ "$fallback_player_client" = "none" ] || [ "$fallback_player_client" = "off" ]; then
    fallback_player_client=""
fi

# Count how many input types are provided
INPUT_COUNT=0
[ -n "$CHANNEL_URL" ] && ((INPUT_COUNT++))
[ -n "$PLAYLIST_URL" ] && ((INPUT_COUNT++))
[ ${#VIDEO_URLS[@]} -gt 0 ] && ((INPUT_COUNT++))

# Validate input
if [ $INPUT_COUNT -eq 0 ]; then
    log_error "No input provided. Please provide one of:"
    echo "  - Channel URL (-c|--channel)"
    echo "  - Playlist URL (-l|--list)"
    echo "  - One or more video URLs"
    echo ""
    show_usage
    exit 1
elif [ $INPUT_COUNT -gt 1 ]; then
    log_error "Multiple input types provided. Please use only one of:"
    echo "  - Channel URL (-c|--channel)"
    echo "  - Playlist URL (-l|--list)"
    echo "  - One or more video URLs"
    echo ""
    log_info "Current inputs:"
    [ -n "$CHANNEL_URL" ] && log_info "  Channel URL: '$CHANNEL_URL'"
    [ -n "$PLAYLIST_URL" ] && log_info "  Playlist URL: '$PLAYLIST_URL'"
    [ ${#VIDEO_URLS[@]} -gt 0 ] && log_info "  Video URLs: '${VIDEO_URLS[*]}'"
    exit 1
fi

# All remaining arguments will be passed to yt-dlp
EXTRA_OPTS=("$@")

# Create download archive directory if it doesn't exist
ARCHIVE_DIR="${HOME}/.yt-dlp/archives"
mkdir -p "$ARCHIVE_DIR"

# Set format and additional options based on download type
FORMAT_OPTS=()
EMBED_SUBS_OPTS=()
WRITE_SUBS_OPTS=()

if [ "$ONLY_AUDIO" = true ]; then
    FORMAT_OPTS=(-f ba)
elif [ "$ONLY_SUBTITLE" = true ]; then
    FORMAT_OPTS=(--skip-download)
    WRITE_SUBS_OPTS=(--write-subs --write-auto-subs)
else
    EMBED_SUBS_OPTS=(--embed-subs)
    WRITE_SUBS_OPTS=(--write-subs --write-auto-subs)
fi

youtube_extractor_args=()
if [ -n "$youtube_player_client" ]; then
    youtube_extractor_args=(--extractor-args "youtube:player_client=${youtube_player_client}")
fi

# Define match filter that allows Rumble videos to bypass subscription check
# For Rumble videos - no filter, for other extractors - check for subscription requirement
MATCH_FILTER="extractor!='Rumble' & extractor!='RumbleEmbed' & availability!='needs_subscription' | extractor='Rumble' | extractor='RumbleEmbed'"

# Handle channel URL mode
if [ -n "$CHANNEL_URL" ]; then
    # Convert @channel URL to channel/videos URL format
    if [[ "$CHANNEL_URL" == *"@"* ]]; then
        CHANNEL_URL="${CHANNEL_URL}/videos"
    fi

    # Generate a unique archive file name based on the channel URL
    ARCHIVE_FILE="${ARCHIVE_DIR}/$(echo "$CHANNEL_URL" | md5sum | cut -d' ' -f1).txt"

    if [ "$REFRESH" = true ]; then
        if [ -f "$ARCHIVE_FILE" ]; then
            log_info "Refresh requested; clearing archive cache at '$ARCHIVE_FILE'."
            rm -f "$ARCHIVE_FILE"
        else
            log_warn "Refresh requested but no archive cache found for '$CHANNEL_URL'."
        fi
    fi

    retry_command "Channel download: ${CHANNEL_URL}" yt-dlp \
        --playlist-reverse \
        "${EMBED_SUBS_OPTS[@]}" \
        -o "$OUTPUT_DIR/%(playlist)s/%(n_entries+1-playlist_index)d.%(title)s.%(ext)s" \
        --cookies-from-browser chrome \
        -N 1 \
        -i \
        "${FORMAT_OPTS[@]}" \
        "${WRITE_SUBS_OPTS[@]}" \
        --sub-langs "en,en-US,zh-Hans,zh-Hant,zh-CN,zh" \
        --sleep-subtitles 1 \
        --continue \
        $( [ "$OVERWRITE" != true ] && echo "--download-archive $ARCHIVE_FILE --no-overwrites" ) \
        $( [ "$OVERWRITE" = true ] && echo "--force-overwrites" ) \
        --extractor-args youtubetab:skip=authcheck \
        --referer "$CHANNEL_URL" \
        --sleep-interval 1 \
        --max-sleep-interval 3 \
        --retries 10 \
        --file-access-retries 5 \
        --fragment-retries 5 \
        --exec after_move:"rm -f -- \"%(filepath)s.ytdl\"" \
        "${youtube_extractor_args[@]}" \
        --add-header "Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
        --add-header "Accept-Language:en-us,en;q=0.5" \
        --add-header "Accept-Encoding:gzip, deflate" \
        --add-header "Accept-Charset:ISO-8859-1,utf-8;q=0.7,*;q=0.7" \
        --add-header "User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36" \
        "${EXTRA_OPTS[@]}" \
        "$CHANNEL_URL"

    channel_status=$?
    exit "$channel_status"

# Handle playlist URL mode
elif [ -n "$PLAYLIST_URL" ]; then
    # Generate a unique archive file name based on the playlist URL
    ARCHIVE_FILE="${ARCHIVE_DIR}/$(echo "$PLAYLIST_URL" | md5sum | cut -d' ' -f1).txt"

    if [ "$REFRESH" = true ]; then
        if [ -f "$ARCHIVE_FILE" ]; then
            log_info "Refresh requested; clearing archive cache at '$ARCHIVE_FILE'."
            rm -f "$ARCHIVE_FILE"
        else
            log_warn "Refresh requested but no archive cache found for '$PLAYLIST_URL'."
        fi
    fi

    retry_command "Playlist download: ${PLAYLIST_URL}" yt-dlp \
        --playlist-reverse \
        "${EMBED_SUBS_OPTS[@]}" \
        -o "$OUTPUT_DIR/%(playlist)s/%(playlist_index)s.%(title)s.%(ext)s" \
        --cookies-from-browser chrome \
        -N 1 \
        -i \
        "${FORMAT_OPTS[@]}" \
        "${WRITE_SUBS_OPTS[@]}" \
        --sub-langs "en,en-US,en-GB,zh-Hans,zh-Hant,zh-CN,zh" \
        --sleep-subtitles 1 \
        --continue \
        $( [ "$OVERWRITE" != true ] && echo "--download-archive $ARCHIVE_FILE --no-overwrites" ) \
        $( [ "$OVERWRITE" = true ] && echo "--force-overwrites" ) \
        --yes-playlist \
        --sleep-interval 1 \
        --max-sleep-interval 3 \
        --retries 10 \
        --file-access-retries 5 \
        --fragment-retries 5 \
        --exec after_move:"rm -f -- \"%(filepath)s.ytdl\"" \
        "${youtube_extractor_args[@]}" \
        --add-header "Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8" \
        --add-header "Accept-Language:en-us,en;q=0.5" \
        --add-header "Accept-Encoding:gzip, deflate" \
        --add-header "Accept-Charset:ISO-8859-1,utf-8;q=0.7,*;q=0.7" \
        --add-header "User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36" \
        "${EXTRA_OPTS[@]}" \
        "$PLAYLIST_URL"

    playlist_status=$?
    exit "$playlist_status"

# Handle individual video URLs mode
else
    overall_exit_code=0
    failed_video_urls=()
    expanded_output_dir="${OUTPUT_DIR/#\~/$HOME}"
    [ -z "$expanded_output_dir" ] && expanded_output_dir="manual_video_downloads"
    manual_archive_hash=$(printf "%s" "$expanded_output_dir" | md5sum | cut -d' ' -f1)
    manual_archive_file="${ARCHIVE_DIR}/manual_urls_${manual_archive_hash}.txt"

    if [ "$REFRESH" = true ]; then
        if [ -f "$manual_archive_file" ]; then
            log_info "Refresh requested; clearing archive cache at '${manual_archive_file}'."
            rm -f "$manual_archive_file"
        else
            log_warn "Refresh requested but no manual video archive found to clear."
        fi
    fi

    [ "$OVERWRITE" != true ] && touch "$manual_archive_file"

    for url in "${VIDEO_URLS[@]}"; do

        if retry_command "Video download: ${url}" download_video_with_fallback "$url" "$manual_archive_file" "$OUTPUT_DIR"
        then
            :
        else
            download_status=$?
            log_error "Skipping ${url} after ${retry_attempt_limit} failed attempts."
            overall_exit_code=$download_status
            failed_video_urls+=("$url")
            continue
        fi
    done

    if [ ${#failed_video_urls[@]} -gt 0 ]; then
        log_warn "Failed videos after ${retry_attempt_limit} attempts:"
        for failed_url in "${failed_video_urls[@]}"; do
            log_warn "  - ${failed_url}"
        done
    fi

    exit "$overall_exit_code"
fi
