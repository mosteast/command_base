#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const os = require("os");
const yargs = require("yargs/yargs");
const chalk = require("chalk");
const readline = require("readline");
const util = require("util");

const { extractAudio } = require("../lib/live_media/extract_audio");
const {
  transcribeWithWhisper,
} = require("../lib/live_media/whisper_transcribe");
const { compressVideo } = require("../lib/live_media/compress_video");

const palette = {
  headline: chalk.cyanBright.bold,
  stage: chalk.cyanBright,
  success: chalk.greenBright,
  warn: chalk.yellowBright,
  error: chalk.redBright,
  dim: chalk.gray,
  path: chalk.cyanBright,
};

const highlightPath = (value) => (value ? palette.path(value) : value);

const MAX_SUPPRESSED_MESSAGES = 800;
const MAX_LOG_HISTORY = 1200;
const MAX_LOG_HISTORY_DISPLAY = 400;
const interactive_terminal = Boolean(
  process.stdout.isTTY && process.stdin.isTTY,
);

const terminal_state = {
  interactive: interactive_terminal,
  logs_visible: !interactive_terminal,
  suppressed_log_count: 0,
  suppressed_messages: [],
  resume_progress_after_logs: null,
  log_history: [],
};

const original_console = {
  log: console.log.bind(console),
  warn: console.warn.bind(console),
  error: console.error.bind(console),
};

let progress_tracker = null;
let keypress_listener_cleanup = null;

function truncate_middle(value, max_length = 60) {
  if (!value) return "";
  if (value.length <= max_length) return value;
  const segment = Math.max(1, Math.floor((max_length - 3) / 2));
  return `${value.slice(0, segment)}...${value.slice(-segment)}`;
}

function store_suppressed_line(level, text) {
  if (text === undefined || text === null) return;
  const normalized = `${text}`;
  if (!normalized) return;
  terminal_state.suppressed_messages.push({ level, text: normalized });
  if (terminal_state.suppressed_messages.length > MAX_SUPPRESSED_MESSAGES) {
    terminal_state.suppressed_messages.splice(
      0,
      terminal_state.suppressed_messages.length - MAX_SUPPRESSED_MESSAGES,
    );
  }
  terminal_state.suppressed_log_count += 1;
}

function record_log_history(level, text) {
  if (!text) return;
  terminal_state.log_history.push({ level, text });
  if (terminal_state.log_history.length > MAX_LOG_HISTORY) {
    terminal_state.log_history.splice(
      0,
      terminal_state.log_history.length - MAX_LOG_HISTORY,
    );
  }
}

function replay_log_history() {
  if (!terminal_state.log_history.length) return;
  const start_index = Math.max(
    0,
    terminal_state.log_history.length - MAX_LOG_HISTORY_DISPLAY,
  );
  for (
    let index = start_index;
    index < terminal_state.log_history.length;
    index += 1
  ) {
    const entry = terminal_state.log_history[index];
    if (!entry || !entry.text) continue;
    const target = original_console[entry.level] || original_console.log;
    target(entry.text);
  }
}

function emit_line(level, line, force = false) {
  const resolved_level = level === "info" ? "log" : level;
  const text = line;
  const should_print = terminal_state.logs_visible || force;
  const should_store = !terminal_state.logs_visible && Boolean(text);

  if (text) {
    record_log_history(resolved_level, text);
  }

  if (should_print) {
    const resume =
      progress_tracker && typeof progress_tracker.pause === "function"
        ? progress_tracker.pause()
        : () => {};
    try {
      const target = original_console[resolved_level] || original_console.log;
      target(text);
    } finally {
      resume();
    }
  }

  if (should_store && text) {
    store_suppressed_line(resolved_level, text);
  }
}

function process_output(level, message, options = {}) {
  if (message === undefined || message === null) return;
  const { force = false } = options;
  const resolved_level = level === "info" ? "log" : level;
  const text = `${message}`;
  if (!text) return;

  const normalized = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  const parts = normalized.split("\n");
  for (let index = 0; index < parts.length; index += 1) {
    const part = parts[index];
    const isTrailingEmpty = index === parts.length - 1 && part.length === 0;
    if (isTrailingEmpty) continue;
    emit_line(resolved_level, part, force);
  }
}

function handle_child_stream(level, chunk) {
  if (chunk === undefined || chunk === null) return;
  const text = Buffer.isBuffer(chunk) ? chunk.toString("utf8") : `${chunk}`;
  if (!text) return;
  process_output(level, text);
}

const child_stdout_handler = (chunk) => handle_child_stream("log", chunk);
const child_stderr_handler = (chunk) => handle_child_stream("warn", chunk);

function create_progress_tracker(state) {
  const tracker_state = {
    active: false,
    stage_label: "",
    stage_index: 0,
    stage_total: 0,
    item_total: 0,
    completed_count: 0,
    detail: "",
    last_render: "",
    pause_depth: 0,
  };

  function is_ready() {
    return Boolean(state.interactive && tracker_state.active);
  }

  function clamp_percent(value) {
    if (Number.isNaN(value)) return 0;
    if (value < 0) return 0;
    if (value > 100) return 100;
    return value;
  }

  function render_line() {
    if (!state.interactive || !tracker_state.active) return;
    if (tracker_state.pause_depth > 0) return;
    const total_items =
      tracker_state.item_total >= 0 ? tracker_state.item_total : 0;
    const completed = Math.min(tracker_state.completed_count, total_items);
    const ratio = total_items > 0 ? completed / total_items : 1;
    const percent = clamp_percent(Math.round(ratio * 100));
    const bar_width = 20;
    const filled = total_items > 0 ? Math.round(ratio * bar_width) : bar_width;
    const empty = Math.max(bar_width - filled, 0);
    const filled_bar = filled > 0 ? palette.success("#".repeat(filled)) : "";
    const empty_bar = empty > 0 ? palette.dim("-".repeat(empty)) : "";
    const stage_total = tracker_state.stage_total || 1;
    const stage_index_label = `${
      tracker_state.stage_index > 0 ? tracker_state.stage_index : 1
    }/${stage_total}`;
    const stage_segment = palette.stage(
      `[${stage_index_label}] ${tracker_state.stage_label || "Processing"}`,
    );
    const counts_segment = palette.stage(`${completed}/${total_items}`);
    const percent_segment = palette.dim(`${percent}%`);
    const detail_segment = tracker_state.detail
      ? ` ${tracker_state.detail}`
      : "";
    const line = `${stage_segment} ${filled_bar}${empty_bar} ${counts_segment} ${percent_segment}${detail_segment}`;
    if (line === tracker_state.last_render) {
      return;
    }
    readline.clearLine(process.stdout, 0);
    readline.cursorTo(process.stdout, 0);
    process.stdout.write(line);
    tracker_state.last_render = line;
  }

  function erase_line() {
    if (!state.interactive) return;
    readline.clearLine(process.stdout, 0);
    readline.cursorTo(process.stdout, 0);
    tracker_state.last_render = "";
  }

  function start_stage(config = {}) {
    tracker_state.item_total = Number(config.item_total || 0);
    tracker_state.stage_label = config.stage_label || "Processing";
    tracker_state.stage_index = Number(config.stage_index || 1);
    tracker_state.stage_total = Number(config.stage_total || 1);
    tracker_state.completed_count = 0;
    tracker_state.detail = "";
    tracker_state.pause_depth = 0;
    tracker_state.last_render = "";

    if (!state.interactive) {
      tracker_state.active = false;
      return false;
    }

    if (tracker_state.item_total <= 0) {
      tracker_state.active = false;
      return false;
    }

    tracker_state.active = true;
    render_line();
    return true;
  }

  function begin_item(detail) {
    if (!is_ready()) return;
    tracker_state.detail = detail || "";
    render_line();
  }

  function complete_item(detail) {
    if (!tracker_state.active) return;
    if (detail !== undefined && detail !== null) {
      tracker_state.detail = detail;
    }
    if (tracker_state.completed_count < tracker_state.item_total) {
      tracker_state.completed_count += 1;
    }
    render_line();
  }

  function finish_stage() {
    if (!tracker_state.active) return;
    tracker_state.active = false;
    tracker_state.pause_depth = 0;
    tracker_state.last_render = "";
    if (state.interactive) {
      process.stdout.write("\n");
    }
  }

  function pause() {
    if (!is_ready()) {
      return () => {};
    }
    tracker_state.pause_depth += 1;
    if (tracker_state.pause_depth === 1) {
      erase_line();
    }
    return () => {
      if (!state.interactive) return;
      tracker_state.pause_depth = Math.max(0, tracker_state.pause_depth - 1);
      if (tracker_state.pause_depth === 0 && tracker_state.active) {
        tracker_state.last_render = "";
        render_line();
      }
    };
  }

  async function run_with_pause(fn) {
    const resume = pause();
    try {
      return await fn();
    } finally {
      resume();
    }
  }

  return {
    start_stage,
    begin_item,
    complete_item,
    finish_stage,
    erase_line,
    render_line,
    pause,
    run_with_pause,
    is_active: () =>
      Boolean(
        state.interactive &&
          tracker_state.active &&
          tracker_state.item_total > 0,
      ),
  };
}

progress_tracker = create_progress_tracker(terminal_state);

function handle_console_output(level, args) {
  const resolved_level = level === "info" ? "log" : level;
  const message = util.format(...args);
  const force = resolved_level === "error";
  process_output(resolved_level, message, { force });
}

console.log = (...args) => handle_console_output("log", args);
console.info = (...args) => handle_console_output("log", args);
console.warn = (...args) => handle_console_output("warn", args);
console.error = (...args) => handle_console_output("error", args);

function toggle_logs() {
  const resume =
    progress_tracker && typeof progress_tracker.pause === "function"
      ? progress_tracker.pause()
      : () => {};
  try {
    if (terminal_state.logs_visible) {
      terminal_state.logs_visible = false;
      const resume_progress = terminal_state.resume_progress_after_logs;
      terminal_state.resume_progress_after_logs = null;
      if (typeof resume_progress === "function") {
        try {
          resume_progress();
        } catch (err) {
          // ignore resume failure
        }
      }

      terminal_state.suppressed_messages.length = 0;
      terminal_state.suppressed_log_count = 0;

      if (terminal_state.interactive && process.stdout.isTTY) {
        try {
          readline.cursorTo(process.stdout, 0, 0);
          readline.clearScreenDown(process.stdout);
        } catch (err) {
          // ignore screen clear failure
        }
      }

      original_console.log(palette.dim("Logs hidden. Press 'l' to show logs."));

      if (
        progress_tracker &&
        typeof progress_tracker.render_line === "function" &&
        progress_tracker.is_active()
      ) {
        progress_tracker.render_line();
      }
      return;
    }

    terminal_state.logs_visible = true;
    if (
      !terminal_state.resume_progress_after_logs &&
      progress_tracker &&
      typeof progress_tracker.pause === "function"
    ) {
      terminal_state.resume_progress_after_logs = progress_tracker.pause();
    }

    if (progress_tracker && typeof progress_tracker.erase_line === "function") {
      try {
        progress_tracker.erase_line();
      } catch (err) {
        // ignore erase failure
      }
    }

    if (terminal_state.interactive && process.stdout.isTTY) {
      try {
        readline.cursorTo(process.stdout, 0, 0);
        readline.clearScreenDown(process.stdout);
      } catch (err) {
        // ignore screen clear failure
      }
    }

    const count = terminal_state.suppressed_log_count;
    const suffix = count
      ? ` (${count} buffered message${count === 1 ? "" : "s"})`
      : "";
    original_console.log(palette.stage(`Logs enabled${suffix}.`));
    replay_log_history();
    terminal_state.suppressed_messages.length = 0;
    terminal_state.suppressed_log_count = 0;
  } finally {
    resume();
  }
}

function setup_keypress_listener() {
  if (!terminal_state.interactive) return null;
  const data_handler = (data) => {
    if (!data) return;
    for (const char of `${data}`) {
      if (char === "l" || char === "L") {
        toggle_logs();
      } else if (char === "\u0003") {
        progress_tracker.erase_line();
        cleanup_keypress_listener();
        process.exit(130);
      }
    }
  };

  try {
    process.stdin.setRawMode(true);
  } catch (err) {
    return null;
  }

  process.stdin.resume();
  process.stdin.setEncoding("utf8");
  process.stdin.on("data", data_handler);

  const exit_handler = () => {
    cleanup_keypress_listener();
  };

  process.on("exit", exit_handler);

  let cleaned = false;

  const cleanup = () => {
    if (cleaned) return;
    cleaned = true;
    process.stdin.removeListener("data", data_handler);
    if (process.stdin.isTTY) {
      try {
        process.stdin.setRawMode(false);
      } catch (err) {
        // ignore cleanup failure
      }
    }
    try {
      process.stdin.pause();
    } catch (err) {
      // ignore pause failure
    }
    process.off("exit", exit_handler);
  };

  return cleanup;
}

function cleanup_keypress_listener() {
  if (typeof keypress_listener_cleanup === "function") {
    keypress_listener_cleanup();
    keypress_listener_cleanup = null;
  }
}

if (terminal_state.interactive) {
  keypress_listener_cleanup = setup_keypress_listener();
}

const VIDEO_EXTENSIONS = new Set([
  ".mp4",
  ".m4v",
  ".mov",
  ".mkv",
  ".webm",
  ".avi",
]);
const DEFAULT_WHISPER_MODEL = process.env.WHISPER_DEFAULT_MODEL || "turbo";
const DEFAULT_TRANSCRIPT_FORMATS = ["srt", "vtt"];
const JOB_MODE_STEP = "step";
const JOB_MODE_FILE = "file";
const DEFAULT_JOB_MODE = JOB_MODE_STEP;
const JOB_MODE_VALUES = new Set([JOB_MODE_STEP, JOB_MODE_FILE]);

const extraBinDirs = [];
if (process.env.HOME) {
  extraBinDirs.push(path.join(process.env.HOME, ".local/bin"));
  extraBinDirs.push(path.join(process.env.HOME, "Library/Python/3.9/bin"));
}
const existingExtraDirs = extraBinDirs.filter((dir) => {
  try {
    fs.accessSync(dir, fs.constants.X_OK);
    return true;
  } catch (err) {
    return false;
  }
});
if (existingExtraDirs.length) {
  const currentPath = process.env.PATH || "";
  process.env.PATH = `${existingExtraDirs.join(path.delimiter)}${currentPath ? `${path.delimiter}${currentPath}` : ""}`;
}

function showHelp() {
  const cmd = path.basename(process.argv[1] || "videos_normalize");
  console.log(palette.headline("Usage:"));
  console.log(`  ${palette.stage(cmd)} <video-file> [options]`);
  console.log("");
  console.log(palette.headline("Audio extraction options:"));
  console.log(
    palette.dim("      --audio-output PATH        Audio output path"),
  );
  console.log(
    palette.dim("      --audio-format EXT         Audio extension override"),
  );
  console.log(
    palette.dim(
      "      --audio-stream INDEX       Audio stream index (default: 0)",
    ),
  );
  console.log(
    palette.dim(
      "      --audio-bitrate RATE       Fallback transcode bitrate (default: 192k)",
    ),
  );
  console.log(
    palette.dim(
      "      --audio-sample-rate HZ     Fallback transcode sample rate",
    ),
  );
  console.log(
    palette.dim(
      "      --audio-source PATH        Use existing audio file (skip extraction)",
    ),
  );
  console.log(
    palette.dim("      --skip-audio               Skip audio extraction step"),
  );
  console.log("");
  console.log(palette.headline("Transcription options:"));
  console.log(
    palette.dim("      --skip-transcript          Skip transcription"),
  );
  console.log(
    palette.dim("      --transcript-dir DIR       Directory for transcripts"),
  );
  console.log(
    palette.dim(
      "      --transcript-output PATH   Desired transcript file path",
    ),
  );
  console.log(
    palette.dim(
      "      --transcript-format FORMAT Transcript format(s), repeat or comma-separated (default: srt,vtt)",
    ),
  );
  console.log(
    palette.dim(
      `      --whisper-model NAME       Whisper model (default: ${DEFAULT_WHISPER_MODEL})`,
    ),
  );
  console.log(palette.dim("      --whisper-language CODE    Force language"));
  console.log(
    palette.dim(
      "      --whisper-task TASK        transcribe (default) or translate",
    ),
  );
  console.log(
    palette.dim("      --whisper-device DEVICE    Device, e.g. cpu or cuda"),
  );
  console.log(
    palette.dim(
      "      --whisper-compute-type VAL Compute type for faster-whisper",
    ),
  );
  console.log(
    palette.dim("      --whisper-bin PATH         Path to whisper executable"),
  );
  console.log(
    palette.dim(
      "      --whisper-extra ARG        Extra whisper CLI args (repeatable)",
    ),
  );
  console.log("");
  console.log(palette.headline("Compression options:"));
  console.log(
    palette.dim("      --skip-compress            Skip video compression"),
  );
  console.log(
    palette.dim("      --compress-output PATH     Output video path"),
  );
  console.log(
    palette.dim("      --compress-crf VALUE       CRF value (default: 23)"),
  );
  console.log(
    palette.dim("      --compress-preset NAME     Preset (default: medium)"),
  );
  console.log(
    palette.dim(
      "      --compress-audio-bitrate RATE Audio bitrate (default: 128k)",
    ),
  );
  console.log(
    palette.dim(
      "      --compress-video-codec NAME Video codec (default: libx264)",
    ),
  );
  console.log(
    palette.dim("      --compress-audio-codec NAME Audio codec (default: aac)"),
  );
  console.log(
    palette.dim(
      "      --compress-pix-format NAME Pixel format (default: yuv420p)",
    ),
  );
  console.log(
    palette.dim(
      "      --compress-max-height PX   Downscale max height (default: 1080)",
    ),
  );
  console.log(
    palette.dim("      --compress-keep-resolution Keep original resolution"),
  );
  console.log(
    palette.dim(
      "      --compress-tune NAME       Optional tune (film, animation, etc.)",
    ),
  );
  console.log(
    palette.dim(
      "      --compress-extra ARG       Extra ffmpeg args (repeatable)",
    ),
  );
  console.log("");
  console.log(palette.headline("Shared options:"));
  console.log(palette.dim("      --ffmpeg PATH              Path to ffmpeg"));
  console.log(palette.dim("      --ffprobe PATH             Path to ffprobe"));
  console.log(
    palette.dim(
      "      --trash-input              Move processed input videos to trash",
    ),
  );
  console.log(
    palette.dim(
      "      --job-mode MODE           Processing strategy: step (default) or file",
    ),
  );
  console.log(
    palette.dim("      --force                    Overwrite existing outputs"),
  );
  console.log(
    palette.dim("  -h, --help                     Show this help message"),
  );
  console.log("");
  console.log(palette.headline("Examples:"));
  console.log(palette.stage(`  ${cmd} --force ~/videos/raw.mp4`));
  console.log(palette.stage(`  ${cmd} --skip-transcript ~/videos/project`));
  console.log(
    palette.stage(
      `  ${cmd} --compress-output ~/videos/raw.compressed.medium.mp4 ~/videos/raw.mp4`,
    ),
  );
  console.log(palette.stage(`  ${cmd} --skip-compress ~/videos/*.mp4`));
  console.log(
    palette.stage(
      `  ${cmd} --job-mode file --skip-transcript ~/videos/**/*.mp4`,
    ),
  );
  console.log(
    palette.stage(
      `  ${cmd} --job-mode file ~/videos/**/*.{mp4,ts,webm,mkv,mov,avi,m4v}(N)`,
    ),
  );
  console.log(
    palette.stage(
      `  ${cmd} --compress-output ~/archive/normalized.mp4 ~/videos/**/*.{mp4,ts,webm,mkv,mov,avi,m4v}(N)`,
    ),
  );
}

function parseNumber(value, label) {
  if (value === undefined || value === null || value === "") return undefined;
  const num = Number(value);
  if (Number.isNaN(num)) {
    throw new Error(`Invalid value for ${label}: ${value}`);
  }
  return num;
}

function parseRepeatable(value) {
  if (!value) return [];
  if (Array.isArray(value)) return value;
  return [value];
}

function coerceArrayOfStrings(value) {
  if (value === undefined || value === null) return [];
  const values = Array.isArray(value) ? value : [value];
  return values
    .filter((item) => item !== undefined && item !== null)
    .map((item) => String(item));
}

function optionProvided(argv, ...names) {
  return names.some((name) => argv[name] !== undefined);
}

function outputExistsPathFromError(err) {
  if (!err) return "";
  if (err.outputPath) return err.outputPath;
  if (typeof err.message === "string") {
    const match = err.message.match(/Output already exists: (.+?)(?:\. |$)/);
    if (match) return match[1];
  }
  return "";
}

async function pathExists(filePath) {
  if (!filePath) return false;
  try {
    await fs.promises.access(filePath, fs.constants.F_OK);
    return true;
  } catch (err) {
    if (err.code === "ENOENT") return false;
    throw err;
  }
}

async function listVideoFilesRecursive(rootDir) {
  const pending = [rootDir];
  const results = [];

  while (pending.length) {
    const current = pending.pop();
    let entries;
    try {
      entries = await fs.promises.readdir(current, { withFileTypes: true });
    } catch (err) {
      if (err && err.code === "ENOENT") {
        continue;
      }
      throw err;
    }

    for (const entry of entries) {
      const fullPath = path.join(current, entry.name);
      if (entry.isDirectory()) {
        pending.push(fullPath);
      } else if (entry.isFile()) {
        const ext = path.extname(entry.name).toLowerCase();
        if (VIDEO_EXTENSIONS.has(ext)) {
          results.push(fullPath);
        }
      }
    }
  }

  results.sort((a, b) => a.localeCompare(b));
  return results;
}

async function findCompressedFallback(rawPath) {
  const directory = path.dirname(rawPath);
  const rawBaseName = path.basename(rawPath, path.extname(rawPath));

  if (!rawBaseName || rawBaseName === "." || rawBaseName === "..") {
    return null;
  }

  const directCandidates = Array.from(VIDEO_EXTENSIONS, (ext) =>
    path.join(directory, `${rawBaseName}.compressed${ext}`),
  );

  for (const candidate of directCandidates) {
    if (await pathExists(candidate)) {
      try {
        const stats = await fs.promises.stat(candidate);
        if (stats.isFile()) {
          return candidate;
        }
      } catch (err) {
        if (err && err.code !== "ENOENT") throw err;
      }
    }
  }

  let directoryEntries;
  try {
    directoryEntries = await fs.promises.readdir(directory, {
      withFileTypes: true,
    });
  } catch (err) {
    if (err && err.code === "ENOENT") {
      return null;
    }
    throw err;
  }

  const prefix = `${rawBaseName}.compressed`;
  for (const entry of directoryEntries) {
    if (!entry.isFile()) continue;
    if (!entry.name.startsWith(prefix)) continue;
    const ext = path.extname(entry.name).toLowerCase();
    if (!VIDEO_EXTENSIONS.has(ext)) continue;
    return path.join(directory, entry.name);
  }

  return null;
}

async function resolveTrashDirectory() {
  const homeDir = os.homedir();
  if (!homeDir) {
    throw new Error("Cannot determine home directory for trash location.");
  }
  const platform = process.platform;
  if (platform === "darwin") {
    return path.join(homeDir, ".Trash");
  }
  if (platform === "linux") {
    return path.join(homeDir, ".local", "share", "Trash", "files");
  }
  throw new Error(`Moving to trash is not supported on platform: ${platform}`);
}

async function moveToTrash(filePath) {
  if (!filePath) {
    throw new Error("moveToTrash: filePath is required");
  }
  const sourcePath = path.resolve(filePath);
  const trashDir = await resolveTrashDirectory();
  await fs.promises.mkdir(trashDir, { recursive: true });

  const baseName = path.basename(sourcePath);
  const ext = path.extname(baseName);
  const baseStem = path.basename(baseName, ext);

  let targetPath = path.join(trashDir, baseName);
  if (await pathExists(targetPath)) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    let attempt = 0;
    do {
      const suffix = attempt ? `-${attempt}` : "";
      targetPath = path.join(
        trashDir,
        `${baseStem}-${timestamp}${suffix}${ext}`,
      );
      attempt += 1;
    } while (await pathExists(targetPath));
  }

  try {
    await fs.promises.rename(sourcePath, targetPath);
  } catch (err) {
    if (err && err.code === "EXDEV") {
      try {
        await fs.promises.copyFile(sourcePath, targetPath);
      } catch (copyErr) {
        try {
          await fs.promises.unlink(targetPath);
        } catch (cleanupErr) {
          // ignore cleanup failures
        }
        throw copyErr;
      }
      await fs.promises.unlink(sourcePath);
    } else {
      throw err;
    }
  }

  return targetPath;
}

function formatDisplayPath(filePath) {
  if (!filePath) return "";
  const absolutePath = path.resolve(filePath);
  const homeDir = os.homedir();
  if (homeDir && absolutePath.startsWith(homeDir)) {
    return `~${absolutePath.slice(homeDir.length)}`;
  }
  return absolutePath;
}

function describeSkipReason(reason) {
  if (!reason) return "";
  if (reason === "whisper-not-found") return "whisper CLI missing";
  if (reason === "exists") return "already exists";
  return reason;
}

const LOG_FILE_PREFIX = "/tmp/log.videos_normalize";
const STAGE_KEYS = ["audio", "transcript", "compression"];
const STAGE_LABELS = {
  audio: "Audio",
  transcript: "Transcription",
  compression: "Compression",
};

function stage_prefix(stage_key) {
  const index = STAGE_KEYS.indexOf(stage_key);
  if (index === -1) return stage_key;
  const label = STAGE_LABELS[stage_key] || stage_key;
  return `[${index + 1}/${STAGE_KEYS.length}] ${label}`;
}

function stage_files_phrase(count) {
  if (count === 1) return "Processing 1 file...";
  return `Processing ${count} files...`;
}

function stage_banner(stage_key, message, formatter = palette.stage) {
  const prefix = stage_prefix(stage_key);
  emit_line("log", formatter(`${prefix} ${message}`), true);
}

function createLogFilePath() {
  const timestamp = Math.floor(Date.now() / 1000);
  return `${LOG_FILE_PREFIX}.${timestamp}.txt`;
}

let runLogFilePath = createLogFilePath();
let currentRunEntries = null;

const runStatistics = {
  stages: STAGE_KEYS.reduce((acc, key) => {
    acc[key] = { success: 0, errors: 0 };
    return acc;
  }, {}),
  errors: [],
  fatalError: null,
};

async function updateRunLog(options = {}) {
  if (!currentRunEntries) return;
  await writeRunLog(currentRunEntries, options);
}

function resolveErrorMessage(err, fallback = "Unknown error") {
  if (!err) return fallback;
  if (typeof err === "string") {
    return err || fallback;
  }
  if (err.stderr && typeof err.stderr === "string" && err.stderr.trim()) {
    return err.stderr.trim();
  }
  if (err.stdout && typeof err.stdout === "string" && err.stdout.trim()) {
    return err.stdout.trim();
  }
  if (typeof err.message === "string" && err.message.trim()) {
    return err.message.trim();
  }
  return fallback;
}

function recordStageSuccess(stageKey) {
  if (!stageKey) return;
  const bucket = runStatistics.stages[stageKey];
  if (bucket) {
    bucket.success += 1;
  }
}

function recordStageFailure(entry, stageKey, message, options = {}) {
  if (!entry || !entry.summary) return;
  const reasonOverride = options.reason || "error";
  entry.summary[stageKey] = {
    skipped: true,
    reason: reasonOverride,
    error: message,
  };
  if (!entry.summary.failures) {
    entry.summary.failures = [];
  }
  entry.summary.failures.push({ stage: stageKey, message });
  const bucket = runStatistics.stages[stageKey];
  if (bucket) {
    bucket.errors += 1;
  }
  const displayPath = formatDisplayPath(
    entry.inputVideo || entry.requestedVideo || entry.summary.inputVideo || "",
  );
  const stageLabel = stageKey || "unknown";
  const location = displayPath || "<unknown>";
  runStatistics.errors.push(`[${stageLabel}] ${location}: ${message}`);
}

function normalizeTranscriptFormats(rawValue) {
  const initial = parseRepeatable(rawValue);
  const flattened = initial
    .flatMap((entry) => `${entry}`.split(",").map((part) => part.trim()))
    .filter((part) => part.length > 0);
  let formats = flattened.length
    ? flattened.map((part) => part.toLowerCase())
    : [...DEFAULT_TRANSCRIPT_FORMATS];
  if (formats.includes("all")) {
    formats = ["txt", "vtt", "srt", "tsv", "json"];
  }
  return Array.from(new Set(formats));
}

async function ensureReadable(filePath, label) {
  try {
    await fs.promises.access(filePath, fs.constants.R_OK);
  } catch (err) {
    throw new Error(`${label} not accessible: ${filePath}`);
  }
}

async function processAudioStage(entries, argv, force) {
  const skipAudio = Boolean(argv["skip-audio"] || argv.skipAudio);
  const initialAudioSource = argv["audio-source"]
    ? path.resolve(argv["audio-source"])
    : null;
  const fallbackSampleRate = parseNumber(
    argv["audio-sample-rate"],
    "--audio-sample-rate",
  );
  const audioOutputOption = argv["audio-output"]
    ? path.resolve(argv["audio-output"])
    : null;
  const stage_entries = entries.filter((entry) => entry && entry.summary);

  const stage_key = "audio";
  const stage_item_count = stage_entries.length;

  if (skipAudio) {
    stage_banner(stage_key, "Skipped.", palette.dim);
  } else if (!stage_item_count) {
    stage_banner(stage_key, "No files to process.", palette.dim);
    await updateRunLog();
    return;
  } else {
    stage_banner(stage_key, stage_files_phrase(stage_item_count));
  }

  let streamIndex = 0;
  if (!skipAudio) {
    const streamIndexRaw = argv["audio-stream"];
    streamIndex = streamIndexRaw !== undefined ? Number(streamIndexRaw) : 0;
    if (Number.isNaN(streamIndex) || streamIndex < 0) {
      throw new Error("Audio stream index must be a non-negative integer.");
    }
    progress_tracker.start_stage({
      stage_label: "Audio",
      stage_index: STAGE_KEYS.indexOf("audio") + 1,
      stage_total: STAGE_KEYS.length,
      item_total: stage_item_count,
    });
  }

  try {
    for (const entry of stage_entries) {
      entry.audioForTranscription = initialAudioSource;
      const displayPath = formatDisplayPath(entry.inputVideo);
      const truncated_display = truncate_middle(displayPath, 60);

      if (!skipAudio && stage_entries.length > 1) {
        console.log(`${palette.dim("  • ")}${highlightPath(displayPath)}`);
      }

      if (!skipAudio) {
        const detail_label = `${palette.dim("Processing:")} ${highlightPath(
          truncated_display,
        )}`;
        progress_tracker.begin_item(detail_label);
      }

      try {
        if (!skipAudio) {
          try {
            const audioResult = await extractAudio({
              inputPath: entry.inputVideo,
              outputPath: audioOutputOption || entry.targetBasePath,
              outputExtension: argv["audio-format"],
              audioStreamIndex: streamIndex,
              force,
              preferCopy: true,
              allowTranscodeFallback: true,
              fallbackBitrate: argv["audio-bitrate"] || "192k",
              fallbackSampleRate,
              ffmpegPath: argv.ffmpeg,
              ffprobePath: argv.ffprobe,
              logger: console,
              commandSilent: true,
              onCommandStdout: child_stdout_handler,
              onCommandStderr: child_stderr_handler,
            });
            entry.audioForTranscription = audioResult.outputPath;
            entry.summary.audio = audioResult;
            console.log(
              `${palette.success("    ✓ Audio saved to ")}${highlightPath(
                audioResult.outputPath,
              )}`,
            );
            recordStageSuccess("audio");
          } catch (err) {
            if (err && err.code === "OUTPUT_EXISTS" && !force) {
              const existingOutput =
                outputExistsPathFromError(err) ||
                (audioOutputOption ? audioOutputOption : "");
              const resolvedExisting = existingOutput || null;
              const fallbackSource = resolvedExisting || entry.inputVideo;
              await ensureReadable(fallbackSource, "Existing audio output");
              entry.audioForTranscription = fallbackSource;
              entry.summary.audio = { skipped: true, reason: "exists" };
              if (resolvedExisting) {
                entry.summary.audio.outputPath = resolvedExisting;
                entry.summary.audio.source = resolvedExisting;
                console.log(
                  `${palette.dim("    • Audio already exists at ")}${highlightPath(
                    resolvedExisting,
                  )}${palette.dim("; skipping (use --force to regenerate).")}`,
                );
              } else {
                entry.summary.audio.source = fallbackSource;
                console.log(
                  palette.dim(
                    "    • Audio output already exists; skipping (use --force to regenerate).",
                  ),
                );
              }
              recordStageSuccess("audio");
            } else {
              const message = resolveErrorMessage(
                err,
                `Audio extraction failed for ${displayPath}`,
              );
              console.error(
                palette.error(`    ✗ Audio extraction failed: ${message}`),
              );
              recordStageFailure(entry, "audio", message);
              entry.audioForTranscription = null;
              continue;
            }
          }
        } else {
          if (!entry.audioForTranscription) {
            const defaultAudioPath = `${entry.targetBasePath}.m4a`;
            if (await pathExists(defaultAudioPath)) {
              entry.audioForTranscription = defaultAudioPath;
            } else {
              entry.audioForTranscription = entry.inputVideo;
            }
          }
          entry.summary.audio = {
            skipped: true,
            source: entry.audioForTranscription,
          };
        }

        if (entry.audioForTranscription) {
          await ensureReadable(
            entry.audioForTranscription,
            "Audio source for transcription",
          );
        }
      } catch (err) {
        const message = resolveErrorMessage(
          err,
          `Audio processing failed for ${displayPath}`,
        );
        console.error(
          palette.error(`    ✗ Audio processing failed: ${message}`),
        );
        recordStageFailure(entry, "audio", message);
        entry.audioForTranscription = null;
        continue;
      } finally {
        progress_tracker.complete_item();
        await updateRunLog();
      }
    }
  } finally {
    progress_tracker.finish_stage();
  }
}

async function processTranscriptionStage(entries, argv, force) {
  const skipTranscript = Boolean(
    argv["skip-transcript"] || argv.skipTranscript,
  );
  const stage_entries = entries.filter((entry) => entry && entry.summary);
  const stage_key = "transcript";
  const stage_item_count = stage_entries.length;

  if (skipTranscript) {
    stage_banner(stage_key, "Skipped.", palette.dim);
    stage_entries.forEach((entry) => {
      entry.summary.transcript = { skipped: true };
    });
    await updateRunLog();
    return;
  }

  if (!stage_item_count) {
    stage_banner(stage_key, "No files to process.", palette.dim);
    await updateRunLog();
    return;
  }

  stage_banner(stage_key, stage_files_phrase(stage_item_count));

  const transcriptOutputArg = argv["transcript-output"];
  const transcriptDirOption =
    argv["transcript-dir"] ||
    (transcriptOutputArg
      ? path.dirname(path.resolve(transcriptOutputArg))
      : undefined);
  const whisperExtraArgs = parseRepeatable(argv["whisper-extra"]);
  const transcriptFormats = normalizeTranscriptFormats(
    argv["transcript-format"],
  );

  progress_tracker.start_stage({
    stage_label: "Transcription",
    stage_index: STAGE_KEYS.indexOf("transcript") + 1,
    stage_total: STAGE_KEYS.length,
    item_total: stage_item_count,
  });

  try {
    for (const entry of stage_entries) {
      const displayPath = formatDisplayPath(entry.inputVideo);
      const truncated_display = truncate_middle(displayPath, 60);
      if (stage_entries.length > 1) {
        console.log(`${palette.dim("  • ")}${highlightPath(displayPath)}`);
      }

      const audioForTranscription =
        entry.audioForTranscription || entry.inputVideo;

      progress_tracker.begin_item(
        `${palette.dim("Transcribing:")} ${highlightPath(truncated_display)}`,
      );

      try {
        const baseDirForTranscript = transcriptDirOption
          ? path.resolve(transcriptDirOption)
          : entry.targetDir;

        const resolvedTranscriptOutput = transcriptOutputArg
          ? path.resolve(transcriptOutputArg)
          : null;
        const targetBaseDir = resolvedTranscriptOutput
          ? path.dirname(resolvedTranscriptOutput)
          : baseDirForTranscript;
        const transcriptBaseName = resolvedTranscriptOutput
          ? path.parse(resolvedTranscriptOutput).name
          : entry.targetBaseName;

        const transcriptTargets = transcriptFormats.map((format) => ({
          format,
          path: path.join(targetBaseDir, `${transcriptBaseName}.${format}`),
        }));

        let missingTargets = transcriptTargets;
        if (!force) {
          const checks = await Promise.all(
            transcriptTargets.map((target) => pathExists(target.path)),
          );
          missingTargets = transcriptTargets.filter(
            (_, index) => !checks[index],
          );
        }

        if (!force && missingTargets.length === 0) {
          transcriptTargets.forEach((target) => {
            console.log(
              `${palette.dim("    • Transcript already exists at ")}${highlightPath(
                target.path,
              )}${palette.dim("; skipping (delete or use --force to regenerate).")}`,
            );
          });
          entry.summary.transcript = {
            outputs: transcriptTargets.map((target) => ({
              format: target.format,
              path: target.path,
              skipped: true,
              reason: "exists",
            })),
            skipped: true,
            reason: "exists",
            path: transcriptTargets.length
              ? transcriptTargets[0].path
              : undefined,
          };
          recordStageSuccess("transcript");
          continue;
        }

        try {
          const transcriptResult = await transcribeWithWhisper({
            inputPath: audioForTranscription,
            outputDir: transcriptDirOption,
            outputFormats: transcriptFormats,
            model: argv["whisper-model"] || DEFAULT_WHISPER_MODEL,
            language: argv["whisper-language"],
            task: argv["whisper-task"],
            device: argv["whisper-device"],
            computeType: argv["whisper-compute-type"],
            whisperPath: argv["whisper-bin"],
            extraArgs: whisperExtraArgs,
            logger: console,
            commandSilent: true,
            onCommandStdout: child_stdout_handler,
            onCommandStderr: child_stderr_handler,
          });

          const finalOutputs = [];
          for (const target of transcriptTargets) {
            const produced = (transcriptResult.outputs || []).find(
              (item) => item.format === target.format,
            );
            let producedPath = produced
              ? produced.path
              : path.join(
                  baseDirForTranscript,
                  `${transcriptBaseName}.${target.format}`,
                );
            const resolvedProducedPath = path.resolve(producedPath);
            const resolvedTargetPath = path.resolve(target.path);

            if (resolvedProducedPath !== resolvedTargetPath) {
              await fs.promises.mkdir(path.dirname(resolvedTargetPath), {
                recursive: true,
              });
              if (force) {
                try {
                  await fs.promises.unlink(resolvedTargetPath);
                } catch (unlinkErr) {
                  if (unlinkErr.code !== "ENOENT") throw unlinkErr;
                }
              }
              if (await pathExists(resolvedProducedPath)) {
                await fs.promises.rename(
                  resolvedProducedPath,
                  resolvedTargetPath,
                );
                producedPath = resolvedTargetPath;
              }
            }

            if (await pathExists(path.resolve(producedPath))) {
              finalOutputs.push({
                format: target.format,
                path: path.resolve(producedPath),
              });
            }
          }

          finalOutputs.forEach((output, index) => {
            if (index === 0) {
              console.log(
                `${palette.success("    ✓ Transcript saved to ")}${highlightPath(
                  output.path,
                )}${palette.success(` [${output.format}]`)}`,
              );
            } else {
              console.log(
                `${palette.dim("      • ")}${highlightPath(output.path)}${palette.dim(
                  ` [${output.format}]`,
                )}`,
              );
            }
          });

          entry.summary.transcript = {
            outputs: finalOutputs,
            flavor: transcriptResult.flavor,
            path: finalOutputs.length ? finalOutputs[0].path : undefined,
          };
          recordStageSuccess("transcript");
        } catch (err) {
          if (err && err.code === "WHISPER_NOT_FOUND") {
            console.warn(
              palette.warn(
                "    ⚠ Whisper CLI not found; transcription skipped. Install openai-whisper or faster-whisper, or pass --skip-transcript to silence this message.",
              ),
            );
            recordStageFailure(entry, "transcript", "Whisper CLI not found", {
              reason: "whisper-not-found",
            });
          } else {
            throw err;
          }
        }
      } catch (err) {
        const resolved = resolveErrorMessage(
          err,
          `Transcription failed for ${displayPath}`,
        );
        console.error(palette.error(`    ✗ Transcription failed: ${resolved}`));
        recordStageFailure(entry, "transcript", resolved);
        continue;
      } finally {
        progress_tracker.complete_item();
        await updateRunLog();
      }
    }
  } finally {
    progress_tracker.finish_stage();
  }
}

async function processCompressionStage(entries, argv, force) {
  const skipCompress = Boolean(argv["skip-compress"] || argv.skipCompress);
  const stage_entries = entries.filter((entry) => entry && entry.summary);

  if (skipCompress) {
    stage_banner("compression", "Skipped.", palette.dim);
    stage_entries.forEach((entry) => {
      if (entry && entry.summary) {
        entry.summary.compression = { skipped: true };
      }
    });
    await updateRunLog();
    return;
  }

  const stage_item_count = stage_entries.length;
  const compressExtraArgs = parseRepeatable(argv["compress-extra"]);
  if (!stage_item_count) {
    stage_banner("compression", "No files to process.", palette.dim);
    await updateRunLog();
    return;
  }

  stage_banner("compression", stage_files_phrase(stage_item_count));

  progress_tracker.start_stage({
    stage_label: "Compression",
    stage_index: STAGE_KEYS.indexOf("compression") + 1,
    stage_total: STAGE_KEYS.length,
    item_total: stage_item_count,
  });

  const crfValue = parseNumber(argv["compress-crf"], "--compress-crf") ?? 23;
  const maxHeightValue = parseNumber(
    argv["compress-max-height"],
    "--compress-max-height",
  );
  const compressOutputOption = argv["compress-output"]
    ? path.resolve(argv["compress-output"])
    : null;
  let presetValue = argv["compress-preset"];
  if (presetValue === undefined || presetValue === null) {
    presetValue = "medium";
  } else {
    presetValue = `${presetValue}`.trim() || "medium";
  }
  const presetLabel = presetValue.replace(/\s+/g, "-");

  try {
    for (const entry of stage_entries) {
      const displayPath = formatDisplayPath(entry.inputVideo);
      const truncated_display = truncate_middle(displayPath, 60);
      if (stage_entries.length > 1) {
        console.log(`${palette.dim("  • ")}${highlightPath(displayPath)}`);
      }

      progress_tracker.begin_item(
        `${palette.dim("Compressing:")} ${highlightPath(truncated_display)}`,
      );

      try {
        try {
          const compressResult = await compressVideo({
            inputPath: entry.inputVideo,
            outputPath:
              compressOutputOption ||
              `${entry.targetBasePath}.compressed.${presetLabel}.mp4`,
            force,
            crf: crfValue,
            preset: presetValue,
            audioBitrate: argv["compress-audio-bitrate"] || "128k",
            videoCodec: argv["compress-video-codec"] || "libx264",
            audioCodec: argv["compress-audio-codec"] || "aac",
            pixelFormat: argv["compress-pix-format"] || "yuv420p",
            keepResolution: Boolean(argv["compress-keep-resolution"]),
            maxHeight: maxHeightValue,
            tune: argv["compress-tune"],
            extraArgs: compressExtraArgs,
            ffmpegPath: argv.ffmpeg,
            logger: console,
            commandSilent: true,
            onCommandStdout: child_stdout_handler,
            onCommandStderr: child_stderr_handler,
          });
          entry.summary.compression = compressResult;
          console.log(
            `${palette.success("    ✓ Video saved to ")}${highlightPath(
              compressResult.outputPath,
            )}`,
          );
          recordStageSuccess("compression");
        } catch (err) {
          if (err && err.code === "OUTPUT_EXISTS" && !force) {
            const existingOutput = outputExistsPathFromError(err);
            entry.summary.compression = {
              skipped: true,
              reason: "exists",
              outputPath: existingOutput,
            };
            if (existingOutput) {
              console.log(
                `${palette.dim("    • Compressed video already exists at ")}${highlightPath(
                  existingOutput,
                )}${palette.dim("; skipping (use --force to regenerate).")}`,
              );
            } else {
              console.log(
                palette.dim(
                  "    • Compressed video output already exists; skipping (use --force to regenerate).",
                ),
              );
            }
            recordStageSuccess("compression");
          } else {
            throw err;
          }
        }
      } catch (err) {
        const resolved = resolveErrorMessage(
          err,
          `Compression failed for ${displayPath}`,
        );
        console.error(palette.error(`    ✗ Compression failed: ${resolved}`));
        recordStageFailure(entry, "compression", resolved);
        continue;
      } finally {
        progress_tracker.complete_item();
        await updateRunLog();
      }
    }
  } finally {
    progress_tracker.finish_stage();
  }
}

async function processEntrySequentially(entry, argv, force) {
  await processAudioStage([entry], argv, force);
  await processTranscriptionStage([entry], argv, force);
  await processCompressionStage([entry], argv, force);
}

async function writeRunLog(entries, options = {}) {
  const { fatalError } = options;
  if (fatalError) {
    runStatistics.fatalError = resolveErrorMessage(
      fatalError,
      fatalError && fatalError.message
        ? fatalError.message
        : "Unknown fatal error",
    );
  }

  const lines = [];
  lines.push(`# videos_normalize run - ${new Date().toISOString()}`);
  lines.push(`files_processed=${entries.length}`);
  lines.push("");
  lines.push("Stage results:");
  STAGE_KEYS.forEach((key) => {
    const bucket = runStatistics.stages[key] || { success: 0, errors: 0 };
    lines.push(`- ${key}: success=${bucket.success} error=${bucket.errors}`);
  });

  lines.push("");
  if (runStatistics.errors.length) {
    lines.push("Errors:");
    runStatistics.errors.forEach((entry, index) => {
      lines.push(`${index + 1}. ${entry}`);
    });
  } else {
    lines.push("Errors: none");
  }

  if (runStatistics.fatalError) {
    lines.push("");
    lines.push(`Fatal error: ${runStatistics.fatalError}`);
  }

  lines.push("");

  try {
    await fs.promises.writeFile(
      runLogFilePath,
      `${lines.join("\n")}\n`,
      "utf8",
    );
  } catch (err) {
    console.error(
      `⚠ Failed to write log file at ${runLogFilePath}: ${resolveErrorMessage(err)}`,
    );
  }
}

async function main() {
  const parser = yargs(process.argv.slice(2))
    .parserConfiguration({
      "camel-case-expansion": true,
      "duplicate-arguments-array": true,
      "flatten-duplicate-arrays": false,
      "strip-aliased": true,
    })
    .help(false)
    .version(false)
    .alias("h", "help")
    .option("audio-output", { type: "string" })
    .option("audio-format", { type: "string" })
    .option("audio-stream", { type: "string" })
    .option("audio-bitrate", { type: "string" })
    .option("audio-sample-rate", { type: "string" })
    .option("audio-source", { type: "string" })
    .option("transcript-dir", { type: "string" })
    .option("transcript-output", { type: "string" })
    .option("transcript-format", { type: "string" })
    .option("whisper-model", { type: "string" })
    .option("whisper-language", { type: "string" })
    .option("whisper-task", { type: "string" })
    .option("whisper-device", { type: "string" })
    .option("whisper-compute-type", { type: "string" })
    .option("whisper-bin", { type: "string" })
    .option("whisper-extra", { type: "array" })
    .option("compress-output", { type: "string" })
    .option("compress-crf", { type: "string" })
    .option("compress-preset", { type: "string" })
    .option("compress-audio-bitrate", { type: "string" })
    .option("compress-video-codec", { type: "string" })
    .option("compress-audio-codec", { type: "string" })
    .option("compress-pix-format", { type: "string" })
    .option("compress-max-height", { type: "string" })
    .option("compress-tune", { type: "string" })
    .option("compress-extra", { type: "array" })
    .option("ffmpeg", { type: "string" })
    .option("ffprobe", { type: "string" })
    .option("job-mode", { type: "string" })
    .option("input", { type: "string" })
    .boolean([
      "help",
      "skip-audio",
      "skip-transcript",
      "skip-compress",
      "force",
      "compress-keep-resolution",
      "trash-input",
    ])
    .coerce("whisper-extra", coerceArrayOfStrings)
    .coerce("compress-extra", coerceArrayOfStrings)
    .wrap(null);

  const argv = parser.parse();

  if (argv.help) {
    showHelp();
    return;
  }

  const rawJobMode = argv["job-mode"] || argv.jobMode;
  const jobMode = rawJobMode
    ? String(rawJobMode).toLowerCase()
    : DEFAULT_JOB_MODE;
  if (!JOB_MODE_VALUES.has(jobMode)) {
    console.error(
      palette.error("Error: --job-mode must be either 'step' or 'file'."),
    );
    process.exit(1);
  }

  const rawInputs = argv._.length ? argv._ : argv.input ? [argv.input] : [];
  if (!rawInputs.length) {
    console.error(palette.error("Error: input video file is required."));
    showHelp();
    process.exit(1);
  }

  const resolvedInputs = rawInputs.map((item) => path.resolve(item));
  if (runLogFilePath) {
    console.log(
      `${palette.dim("Run log will be written to ")}${highlightPath(
        runLogFilePath,
      )}`,
    );
  }
  const entrySpecs = [];

  for (const candidate of resolvedInputs) {
    let stats;
    try {
      stats = await fs.promises.stat(candidate);
    } catch (err) {
      if (err && err.code === "ENOENT") {
        const ext = path.extname(candidate).toLowerCase();
        if (VIDEO_EXTENSIONS.has(ext)) {
          try {
            const fallback = await findCompressedFallback(candidate);
            if (fallback) {
              entrySpecs.push({
                requestedPath: candidate,
                actualPath: fallback,
                usedFallback: true,
              });
              continue;
            }
          } catch (fallbackErr) {
            console.error(
              palette.error(
                `Error searching for compressed fallback: ${candidate}`,
              ),
            );
            if (fallbackErr && fallbackErr.message) {
              console.error(palette.error(fallbackErr.message));
            }
            process.exit(1);
          }
        }
        console.error(
          palette.error(`Error accessing input path: ${candidate}`),
        );
        console.error(palette.error(`File not found: ${candidate}`));
        process.exit(1);
      }
      console.error(palette.error(`Error accessing input path: ${candidate}`));
      if (err && err.message) {
        console.error(palette.error(err.message));
      }
      process.exit(1);
    }

    if (stats.isDirectory()) {
      let videoFiles;
      try {
        videoFiles = await listVideoFilesRecursive(candidate);
      } catch (dirErr) {
        console.error(palette.error(`Error reading directory: ${candidate}`));
        if (dirErr && dirErr.message) {
          console.error(palette.error(dirErr.message));
        }
        process.exit(1);
      }
      if (!videoFiles.length) {
        console.error(
          palette.error(
            `Error: directory contains no supported video files: ${candidate}`,
          ),
        );
        process.exit(1);
      }
      for (const filePath of videoFiles) {
        entrySpecs.push({
          requestedPath: filePath,
          actualPath: filePath,
          usedFallback: false,
        });
      }
      continue;
    }

    if (stats.isFile()) {
      entrySpecs.push({
        requestedPath: candidate,
        actualPath: candidate,
        usedFallback: false,
      });
      continue;
    }

    console.error(palette.error(`Error: unsupported input type: ${candidate}`));
    process.exit(1);
  }

  if (entrySpecs.length > 1) {
    const singleOnlyOptions = [
      ["audio-output", "audioOutput"],
      ["audio-source", "audioSource"],
      ["transcript-output", "transcriptOutput"],
      ["compress-output", "compressOutput"],
    ];

    for (const names of singleOnlyOptions) {
      if (optionProvided(argv, ...names)) {
        console.error(
          palette.error(
            `Error: --${names[0]} can only be used when processing a single input file.`,
          ),
        );
        process.exit(1);
      }
    }
  }

  const force = Boolean(argv.force);
  const trashInput = Boolean(argv["trash-input"] || argv.trashInput);

  const entries = [];
  const seenJobTargets = new Map();

  for (const spec of entrySpecs) {
    const actualPath = path.resolve(spec.actualPath);
    const requestedPath = path.resolve(spec.requestedPath);

    try {
      await ensureReadable(actualPath, "Input video");
      const fileStats = await fs.promises.stat(actualPath);
      if (!fileStats.isFile()) {
        console.error(
          palette.error(
            `Error: expected a video file but got a directory: ${actualPath}`,
          ),
        );
        process.exit(1);
      }
    } catch (err) {
      console.error(
        palette.error(
          err && err.message
            ? err.message
            : `Input video not accessible: ${actualPath}`,
        ),
      );
      process.exit(1);
    }

    const referencePath = spec.usedFallback ? requestedPath : actualPath;
    const referenceDir = path.dirname(referencePath);
    const referenceExt = path.extname(referencePath);
    let referenceBase = path.basename(referencePath, referenceExt);
    if (!referenceBase) {
      referenceBase = path.basename(actualPath, path.extname(actualPath));
    }
    const targetBasePath = path.join(referenceDir, referenceBase);

    const dedupeKey = path.resolve(targetBasePath);
    if (!force && seenJobTargets.has(dedupeKey)) {
      const previous = seenJobTargets.get(dedupeKey);
      const currentLabel = formatDisplayPath(requestedPath);
      const previousLabel = formatDisplayPath(previous.requestedPath);
      console.log(
        `${palette.dim("Skipping duplicate job for ")}${highlightPath(
          currentLabel,
        )}${palette.dim("; already scheduled for ")}${highlightPath(
          previousLabel,
        )}${palette.dim(". Use --force to rerun.")}`,
      );
      continue;
    }

    const entry = {
      inputVideo: actualPath,
      requestedVideo: requestedPath,
      usedFallback: Boolean(spec.usedFallback),
      targetDir: referenceDir,
      targetBaseName: referenceBase,
      targetBasePath,
      summary: {
        inputVideo: requestedPath,
        sourceVideo: actualPath,
      },
    };

    if (entry.usedFallback) {
      entry.summary.fallback = {
        requested: requestedPath,
        source: actualPath,
      };
    }

    seenJobTargets.set(dedupeKey, {
      requestedPath,
      actualPath,
    });

    entries.push(entry);
  }

  for (const entry of entries) {
    if (entry.usedFallback) {
      const missingDisplay = formatDisplayPath(entry.requestedVideo);
      const replacementDisplay = formatDisplayPath(entry.inputVideo);
      console.warn(
        `${palette.warn("⚠ Raw video missing at ")}${highlightPath(
          missingDisplay,
        )}${palette.warn("; using compressed file ")}${highlightPath(
          replacementDisplay,
        )}${palette.warn(".")}`,
      );
    }
  }

  currentRunEntries = entries;
  await updateRunLog();

  try {
    if (jobMode === JOB_MODE_FILE) {
      for (let index = 0; index < entries.length; index += 1) {
        const entry = entries[index];
        if (entries.length > 1) {
          const displayTarget = formatDisplayPath(
            entry.requestedVideo || entry.inputVideo,
          );
          console.log("");
          console.log(
            `${palette.stage(
              `Processing file (${index + 1}/${entries.length}): `,
            )}${highlightPath(displayTarget)}`,
          );
        }
        await processEntrySequentially(entry, argv, force);
      }
    } else {
      await processAudioStage(entries, argv, force);
      await processTranscriptionStage(entries, argv, force);
      await processCompressionStage(entries, argv, force);
    }
  } catch (err) {
    console.error("");
    console.error(palette.error(`Failed: ${err.message}`));
    await writeRunLog(entries, { fatalError: err });
    cleanup_keypress_listener();
    process.exit(1);
  }

  const summaries = [];

  for (const entry of entries) {
    const summary = entry.summary;
    if (trashInput) {
      try {
        const trashedPath = await moveToTrash(entry.inputVideo);
        const displayPath = formatDisplayPath(trashedPath);
        summary.original = {
          trashed: true,
          trashPath: trashedPath,
        };
        console.log(
          `${palette.dim("  Original:   moved to trash -> ")}${highlightPath(
            displayPath,
          )}`,
        );
      } catch (trashErr) {
        console.warn(
          palette.warn(
            `  ⚠ Failed to move original video to trash: ${trashErr.message}`,
          ),
        );
        summary.original = {
          trashed: false,
          error: trashErr.message,
        };
      }
    }
    summaries.push(summary);
  }

  if (summaries.length > 1) {
    console.log("");
    console.log(palette.headline(`Processed ${summaries.length} files:`));
    for (const item of summaries) {
      const inputDisplay = formatDisplayPath(item.inputVideo);
      console.log(`${palette.stage("  - ")}${highlightPath(inputDisplay)}`);
      if (item.fallback && item.fallback.source) {
        const fallbackDisplay = formatDisplayPath(item.fallback.source);
        console.log(
          `${palette.dim("      Fallback: used ")}${highlightPath(
            fallbackDisplay,
          )}`,
        );
      }
      if (item.audio && item.audio.outputPath) {
        const audioDisplay = formatDisplayPath(item.audio.outputPath);
        const suffix =
          item.audio.skipped && item.audio.reason === "exists"
            ? palette.dim(" (already exists)")
            : "";
        console.log(
          `${palette.success("      Audio: ")}${highlightPath(
            audioDisplay,
          )}${suffix}`,
        );
      } else if (item.audio && item.audio.skipped) {
        const reason = describeSkipReason(item.audio.reason);
        const detail = item.audio.error ? ` - ${item.audio.error}` : "";
        console.log(
          palette.dim(
            `      Audio: skipped${reason ? ` (${reason})` : ""}${detail}`,
          ),
        );
      }
      if (
        item.transcript &&
        item.transcript.outputs &&
        item.transcript.outputs.length
      ) {
        const parts = item.transcript.outputs.map((output) => {
          const transcriptDisplay = formatDisplayPath(output.path);
          const suffix =
            output.skipped && output.reason === "exists"
              ? palette.dim(" (already exists)")
              : "";
          const label = output.format ? palette.dim(` [${output.format}]`) : "";
          return `${highlightPath(transcriptDisplay)}${suffix}${label}`;
        });
        const separator = palette.dim(", ");
        console.log(
          `${palette.success("      Transcript: ")}${parts.join(separator)}`,
        );
      } else if (item.transcript && item.transcript.path) {
        const transcriptDisplay = formatDisplayPath(item.transcript.path);
        const suffix =
          item.transcript.skipped && item.transcript.reason === "exists"
            ? palette.dim(" (already exists)")
            : "";
        console.log(
          `${palette.success("      Transcript: ")}${highlightPath(
            transcriptDisplay,
          )}${suffix}`,
        );
      } else if (item.transcript && item.transcript.skipped) {
        const reason = describeSkipReason(item.transcript.reason) || "skipped";
        const detail = item.transcript.error
          ? ` - ${item.transcript.error}`
          : "";
        console.log(palette.dim(`      Transcript: ${reason}${detail}`));
      }
      if (item.compression && item.compression.outputPath) {
        const videoDisplay = formatDisplayPath(item.compression.outputPath);
        const suffix =
          item.compression.skipped && item.compression.reason === "exists"
            ? palette.dim(" (already exists)")
            : "";
        console.log(
          `${palette.success("      Video: ")}${highlightPath(
            videoDisplay,
          )}${suffix}`,
        );
      } else if (item.compression && item.compression.skipped) {
        const reason = describeSkipReason(item.compression.reason);
        const detail = item.compression.error
          ? ` - ${item.compression.error}`
          : "";
        console.log(
          palette.dim(
            `      Video: skipped${reason ? ` (${reason})` : ""}${detail}`,
          ),
        );
      }
      if (item.original) {
        if (item.original.trashed && item.original.trashPath) {
          const trashDisplay = formatDisplayPath(item.original.trashPath);
          console.log(
            `${palette.dim("      Original: trashed -> ")}${highlightPath(
              trashDisplay,
            )}`,
          );
        } else if (item.original.error) {
          console.log(
            palette.warn(
              `      Original: trash failed (${item.original.error})`,
            ),
          );
        }
      }
    }
  }

  await writeRunLog(entries);
  cleanup_keypress_listener();
}

main();
