#!/usr/bin/env node

const fs = require("fs");
const path = require("path");
const os = require("os");
const yargs = require("yargs/yargs");

const { extractAudio } = require("../lib/live_media/extract_audio");
const {
  transcribeWithWhisper,
} = require("../lib/live_media/whisper_transcribe");
const { compressVideo } = require("../lib/live_media/compress_video");

const VIDEO_EXTENSIONS = new Set([
  ".mp4",
  ".m4v",
  ".mov",
  ".mkv",
  ".webm",
  ".avi",
]);
const DEFAULT_WHISPER_MODEL = process.env.WHISPER_DEFAULT_MODEL || "turbo";
const DEFAULT_TRANSCRIPT_FORMATS = ["srt", "vtt"];
const JOB_MODE_STEP = "step";
const JOB_MODE_FILE = "file";
const DEFAULT_JOB_MODE = JOB_MODE_STEP;
const JOB_MODE_VALUES = new Set([JOB_MODE_STEP, JOB_MODE_FILE]);

const extraBinDirs = [];
if (process.env.HOME) {
  extraBinDirs.push(path.join(process.env.HOME, ".local/bin"));
  extraBinDirs.push(path.join(process.env.HOME, "Library/Python/3.9/bin"));
}
const existingExtraDirs = extraBinDirs.filter((dir) => {
  try {
    fs.accessSync(dir, fs.constants.X_OK);
    return true;
  } catch (err) {
    return false;
  }
});
if (existingExtraDirs.length) {
  const currentPath = process.env.PATH || "";
  process.env.PATH = `${existingExtraDirs.join(path.delimiter)}${currentPath ? `${path.delimiter}${currentPath}` : ""}`;
}

function showHelp() {
  const cmd = path.basename(process.argv[1] || "videos_normalize");
  console.log("Usage:");
  console.log(`  ${cmd} <video-file> [options]`);
  console.log("");
  console.log("Audio extraction options:");
  console.log("      --audio-output PATH        Audio output path");
  console.log("      --audio-format EXT         Audio extension override");
  console.log(
    "      --audio-stream INDEX       Audio stream index (default: 0)",
  );
  console.log(
    "      --audio-bitrate RATE       Fallback transcode bitrate (default: 192k)",
  );
  console.log(
    "      --audio-sample-rate HZ     Fallback transcode sample rate",
  );
  console.log(
    "      --audio-source PATH        Use existing audio file (skip extraction)",
  );
  console.log("      --skip-audio               Skip audio extraction step");
  console.log("");
  console.log("Transcription options:");
  console.log("      --skip-transcript          Skip transcription");
  console.log("      --transcript-dir DIR       Directory for transcripts");
  console.log("      --transcript-output PATH   Desired transcript file path");
  console.log(
    "      --transcript-format FORMAT Transcript format(s), repeat or comma-separated (default: srt,vtt)",
  );
  console.log(
    `      --whisper-model NAME       Whisper model (default: ${DEFAULT_WHISPER_MODEL})`,
  );
  console.log("      --whisper-language CODE    Force language");
  console.log(
    "      --whisper-task TASK        transcribe (default) or translate",
  );
  console.log("      --whisper-device DEVICE    Device, e.g. cpu or cuda");
  console.log(
    "      --whisper-compute-type VAL Compute type for faster-whisper",
  );
  console.log("      --whisper-bin PATH         Path to whisper executable");
  console.log(
    "      --whisper-extra ARG        Extra whisper CLI args (repeatable)",
  );
  console.log("");
  console.log("Compression options:");
  console.log("      --skip-compress            Skip video compression");
  console.log("      --compress-output PATH     Output video path");
  console.log("      --compress-crf VALUE       CRF value (default: 23)");
  console.log("      --compress-preset NAME     Preset (default: medium)");
  console.log(
    "      --compress-audio-bitrate RATE Audio bitrate (default: 128k)",
  );
  console.log(
    "      --compress-video-codec NAME Video codec (default: libx264)",
  );
  console.log("      --compress-audio-codec NAME Audio codec (default: aac)");
  console.log(
    "      --compress-pix-format NAME Pixel format (default: yuv420p)",
  );
  console.log(
    "      --compress-max-height PX   Downscale max height (default: 1080)",
  );
  console.log("      --compress-keep-resolution Keep original resolution");
  console.log(
    "      --compress-tune NAME       Optional tune (film, animation, etc.)",
  );
  console.log(
    "      --compress-extra ARG       Extra ffmpeg args (repeatable)",
  );
  console.log("");
  console.log("Shared options:");
  console.log("      --ffmpeg PATH              Path to ffmpeg");
  console.log("      --ffprobe PATH             Path to ffprobe");
  console.log(
    "      --trash-input              Move processed input videos to trash",
  );
  console.log(
    "      --job-mode MODE           Processing strategy: step (default) or file",
  );
  console.log("      --force                    Overwrite existing outputs");
  console.log("  -h, --help                     Show this help message");
  console.log("");
  console.log("Examples:");
  console.log(`  ${cmd} --force ~/videos/raw.mp4`);
  console.log(`  ${cmd} --skip-transcript ~/videos/project`);
  console.log(
    `  ${cmd} --compress-output ~/videos/raw.compressed.medium.mp4 ~/videos/raw.mp4`,
  );
  console.log(`  ${cmd} --skip-compress ~/videos/*.mp4`);
  console.log(`  ${cmd} --job-mode file --skip-transcript ~/videos/**/*.mp4`);
}

function parseNumber(value, label) {
  if (value === undefined || value === null || value === "") return undefined;
  const num = Number(value);
  if (Number.isNaN(num)) {
    throw new Error(`Invalid value for ${label}: ${value}`);
  }
  return num;
}

function parseRepeatable(value) {
  if (!value) return [];
  if (Array.isArray(value)) return value;
  return [value];
}

function coerceArrayOfStrings(value) {
  if (value === undefined || value === null) return [];
  const values = Array.isArray(value) ? value : [value];
  return values
    .filter((item) => item !== undefined && item !== null)
    .map((item) => String(item));
}

function optionProvided(argv, ...names) {
  return names.some((name) => argv[name] !== undefined);
}

function outputExistsPathFromError(err) {
  if (!err) return "";
  if (err.outputPath) return err.outputPath;
  if (typeof err.message === "string") {
    const match = err.message.match(/Output already exists: (.+?)(?:\. |$)/);
    if (match) return match[1];
  }
  return "";
}

async function pathExists(filePath) {
  if (!filePath) return false;
  try {
    await fs.promises.access(filePath, fs.constants.F_OK);
    return true;
  } catch (err) {
    if (err.code === "ENOENT") return false;
    throw err;
  }
}

async function listVideoFilesRecursive(rootDir) {
  const pending = [rootDir];
  const results = [];

  while (pending.length) {
    const current = pending.pop();
    let entries;
    try {
      entries = await fs.promises.readdir(current, { withFileTypes: true });
    } catch (err) {
      if (err && err.code === "ENOENT") {
        continue;
      }
      throw err;
    }

    for (const entry of entries) {
      const fullPath = path.join(current, entry.name);
      if (entry.isDirectory()) {
        pending.push(fullPath);
      } else if (entry.isFile()) {
        const ext = path.extname(entry.name).toLowerCase();
        if (VIDEO_EXTENSIONS.has(ext)) {
          results.push(fullPath);
        }
      }
    }
  }

  results.sort((a, b) => a.localeCompare(b));
  return results;
}

async function findCompressedFallback(rawPath) {
  const directory = path.dirname(rawPath);
  const rawBaseName = path.basename(rawPath, path.extname(rawPath));

  if (!rawBaseName || rawBaseName === "." || rawBaseName === "..") {
    return null;
  }

  const directCandidates = Array.from(VIDEO_EXTENSIONS, (ext) =>
    path.join(directory, `${rawBaseName}.compressed${ext}`),
  );

  for (const candidate of directCandidates) {
    if (await pathExists(candidate)) {
      try {
        const stats = await fs.promises.stat(candidate);
        if (stats.isFile()) {
          return candidate;
        }
      } catch (err) {
        if (err && err.code !== "ENOENT") throw err;
      }
    }
  }

  let directoryEntries;
  try {
    directoryEntries = await fs.promises.readdir(directory, {
      withFileTypes: true,
    });
  } catch (err) {
    if (err && err.code === "ENOENT") {
      return null;
    }
    throw err;
  }

  const prefix = `${rawBaseName}.compressed`;
  for (const entry of directoryEntries) {
    if (!entry.isFile()) continue;
    if (!entry.name.startsWith(prefix)) continue;
    const ext = path.extname(entry.name).toLowerCase();
    if (!VIDEO_EXTENSIONS.has(ext)) continue;
    return path.join(directory, entry.name);
  }

  return null;
}

async function resolveTrashDirectory() {
  const homeDir = os.homedir();
  if (!homeDir) {
    throw new Error("Cannot determine home directory for trash location.");
  }
  const platform = process.platform;
  if (platform === "darwin") {
    return path.join(homeDir, ".Trash");
  }
  if (platform === "linux") {
    return path.join(homeDir, ".local", "share", "Trash", "files");
  }
  throw new Error(`Moving to trash is not supported on platform: ${platform}`);
}

async function moveToTrash(filePath) {
  if (!filePath) {
    throw new Error("moveToTrash: filePath is required");
  }
  const sourcePath = path.resolve(filePath);
  const trashDir = await resolveTrashDirectory();
  await fs.promises.mkdir(trashDir, { recursive: true });

  const baseName = path.basename(sourcePath);
  const ext = path.extname(baseName);
  const baseStem = path.basename(baseName, ext);

  let targetPath = path.join(trashDir, baseName);
  if (await pathExists(targetPath)) {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    let attempt = 0;
    do {
      const suffix = attempt ? `-${attempt}` : "";
      targetPath = path.join(
        trashDir,
        `${baseStem}-${timestamp}${suffix}${ext}`,
      );
      attempt += 1;
    } while (await pathExists(targetPath));
  }

  try {
    await fs.promises.rename(sourcePath, targetPath);
  } catch (err) {
    if (err && err.code === "EXDEV") {
      try {
        await fs.promises.copyFile(sourcePath, targetPath);
      } catch (copyErr) {
        try {
          await fs.promises.unlink(targetPath);
        } catch (cleanupErr) {
          // ignore cleanup failures
        }
        throw copyErr;
      }
      await fs.promises.unlink(sourcePath);
    } else {
      throw err;
    }
  }

  return targetPath;
}

function formatDisplayPath(filePath) {
  if (!filePath) return "";
  const absolutePath = path.resolve(filePath);
  const homeDir = os.homedir();
  if (homeDir && absolutePath.startsWith(homeDir)) {
    return `~${absolutePath.slice(homeDir.length)}`;
  }
  return absolutePath;
}

function describeSkipReason(reason) {
  if (!reason) return "";
  if (reason === "whisper-not-found") return "whisper CLI missing";
  if (reason === "exists") return "already exists";
  return reason;
}

const LOG_FILE_PREFIX = "/tmp/log.videos_normalize";
const STAGE_KEYS = ["audio", "transcript", "compression"];

function createLogFilePath() {
  const timestamp = Math.floor(Date.now() / 1000);
  return `${LOG_FILE_PREFIX}.${timestamp}.txt`;
}

let runLogFilePath = createLogFilePath();
let currentRunEntries = null;

const runStatistics = {
  stages: STAGE_KEYS.reduce((acc, key) => {
    acc[key] = { success: 0, errors: 0 };
    return acc;
  }, {}),
  errors: [],
  fatalError: null,
};

async function updateRunLog(options = {}) {
  if (!currentRunEntries) return;
  await writeRunLog(currentRunEntries, options);
}

function resolveErrorMessage(err, fallback = "Unknown error") {
  if (!err) return fallback;
  if (typeof err === "string") {
    return err || fallback;
  }
  if (err.stderr && typeof err.stderr === "string" && err.stderr.trim()) {
    return err.stderr.trim();
  }
  if (err.stdout && typeof err.stdout === "string" && err.stdout.trim()) {
    return err.stdout.trim();
  }
  if (typeof err.message === "string" && err.message.trim()) {
    return err.message.trim();
  }
  return fallback;
}

function recordStageSuccess(stageKey) {
  if (!stageKey) return;
  const bucket = runStatistics.stages[stageKey];
  if (bucket) {
    bucket.success += 1;
  }
}

function recordStageFailure(entry, stageKey, message, options = {}) {
  if (!entry || !entry.summary) return;
  const reasonOverride = options.reason || "error";
  entry.summary[stageKey] = {
    skipped: true,
    reason: reasonOverride,
    error: message,
  };
  if (!entry.summary.failures) {
    entry.summary.failures = [];
  }
  entry.summary.failures.push({ stage: stageKey, message });
  const bucket = runStatistics.stages[stageKey];
  if (bucket) {
    bucket.errors += 1;
  }
  const displayPath = formatDisplayPath(
    entry.inputVideo || entry.requestedVideo || entry.summary.inputVideo || "",
  );
  const stageLabel = stageKey || "unknown";
  const location = displayPath || "<unknown>";
  runStatistics.errors.push(`[${stageLabel}] ${location}: ${message}`);
}

function normalizeTranscriptFormats(rawValue) {
  const initial = parseRepeatable(rawValue);
  const flattened = initial
    .flatMap((entry) => `${entry}`.split(",").map((part) => part.trim()))
    .filter((part) => part.length > 0);
  let formats = flattened.length
    ? flattened.map((part) => part.toLowerCase())
    : [...DEFAULT_TRANSCRIPT_FORMATS];
  if (formats.includes("all")) {
    formats = ["txt", "vtt", "srt", "tsv", "json"];
  }
  return Array.from(new Set(formats));
}

async function ensureReadable(filePath, label) {
  try {
    await fs.promises.access(filePath, fs.constants.R_OK);
  } catch (err) {
    throw new Error(`${label} not accessible: ${filePath}`);
  }
}

async function processAudioStage(entries, argv, force) {
  const skipAudio = Boolean(argv["skip-audio"] || argv.skipAudio);
  const initialAudioSource = argv["audio-source"]
    ? path.resolve(argv["audio-source"])
    : null;
  const fallbackSampleRate = parseNumber(
    argv["audio-sample-rate"],
    "--audio-sample-rate",
  );
  const audioOutputOption = argv["audio-output"]
    ? path.resolve(argv["audio-output"])
    : null;

  if (skipAudio) {
    console.log("[1/3] Audio extraction skipped.");
  } else {
    const label =
      entries.length > 1
        ? "[1/3] Extracting audio for all files..."
        : "[1/3] Extracting audio...";
    console.log(label);
  }

  let streamIndex = 0;
  if (!skipAudio) {
    const streamIndexRaw = argv["audio-stream"];
    streamIndex = streamIndexRaw !== undefined ? Number(streamIndexRaw) : 0;
    if (Number.isNaN(streamIndex) || streamIndex < 0) {
      throw new Error("Audio stream index must be a non-negative integer.");
    }
  }

  for (const entry of entries) {
    if (!entry || !entry.summary) continue;

    entry.audioForTranscription = initialAudioSource;
    const displayPath = formatDisplayPath(entry.inputVideo);

    if (!skipAudio && entries.length > 1) {
      console.log(`  • ${displayPath}`);
    }

    try {
      if (!skipAudio) {
        try {
          const audioResult = await extractAudio({
            inputPath: entry.inputVideo,
            outputPath: audioOutputOption || entry.targetBasePath,
            outputExtension: argv["audio-format"],
            audioStreamIndex: streamIndex,
            force,
            preferCopy: true,
            allowTranscodeFallback: true,
            fallbackBitrate: argv["audio-bitrate"] || "192k",
            fallbackSampleRate,
            ffmpegPath: argv.ffmpeg,
            ffprobePath: argv.ffprobe,
            logger: console,
          });
          entry.audioForTranscription = audioResult.outputPath;
          entry.summary.audio = audioResult;
          console.log(`    ✓ Audio saved to ${audioResult.outputPath}`);
          recordStageSuccess("audio");
        } catch (err) {
          if (err && err.code === "OUTPUT_EXISTS" && !force) {
            const existingOutput =
              outputExistsPathFromError(err) ||
              (audioOutputOption ? audioOutputOption : "");
            const resolvedExisting = existingOutput || null;
            const fallbackSource = resolvedExisting || entry.inputVideo;
            await ensureReadable(fallbackSource, "Existing audio output");
            entry.audioForTranscription = fallbackSource;
            entry.summary.audio = { skipped: true, reason: "exists" };
            if (resolvedExisting) {
              entry.summary.audio.outputPath = resolvedExisting;
              entry.summary.audio.source = resolvedExisting;
              console.log(
                `    • Audio already exists at ${resolvedExisting}; skipping (use --force to regenerate).`,
              );
            } else {
              entry.summary.audio.source = fallbackSource;
              console.log(
                "    • Audio output already exists; skipping (use --force to regenerate).",
              );
            }
            recordStageSuccess("audio");
          } else {
            const message = resolveErrorMessage(
              err,
              `Audio extraction failed for ${displayPath}`,
            );
            console.error(`    ✗ Audio extraction failed: ${message}`);
            recordStageFailure(entry, "audio", message);
            entry.audioForTranscription = null;
            continue;
          }
        }
      } else {
        if (!entry.audioForTranscription) {
          const defaultAudioPath = `${entry.targetBasePath}.m4a`;
          if (await pathExists(defaultAudioPath)) {
            entry.audioForTranscription = defaultAudioPath;
          } else {
            entry.audioForTranscription = entry.inputVideo;
          }
        }
        entry.summary.audio = {
          skipped: true,
          source: entry.audioForTranscription,
        };
      }

      if (entry.audioForTranscription) {
        await ensureReadable(
          entry.audioForTranscription,
          "Audio source for transcription",
        );
      }
    } catch (err) {
      const message = resolveErrorMessage(
        err,
        `Audio processing failed for ${displayPath}`,
      );
      console.error(`    ✗ Audio processing failed: ${message}`);
      recordStageFailure(entry, "audio", message);
      entry.audioForTranscription = null;
      continue;
    } finally {
      await updateRunLog();
    }
  }
}

async function processTranscriptionStage(entries, argv, force) {
  const skipTranscript = Boolean(
    argv["skip-transcript"] || argv.skipTranscript,
  );

  if (skipTranscript) {
    console.log("[2/3] Transcription skipped.");
    entries.forEach((entry) => {
      if (entry && entry.summary) {
        entry.summary.transcript = { skipped: true };
      }
    });
    await updateRunLog();
    return;
  }

  const transcriptOutputArg = argv["transcript-output"];
  const transcriptDirOption =
    argv["transcript-dir"] ||
    (transcriptOutputArg
      ? path.dirname(path.resolve(transcriptOutputArg))
      : undefined);
  const whisperExtraArgs = parseRepeatable(argv["whisper-extra"]);
  const transcriptFormats = normalizeTranscriptFormats(
    argv["transcript-format"],
  );

  const label =
    entries.length > 1
      ? "[2/3] Transcribing with whisper for all files..."
      : "[2/3] Transcribing with whisper...";
  console.log(label);

  for (const entry of entries) {
    if (!entry || !entry.summary) continue;
    const displayPath = formatDisplayPath(entry.inputVideo);
    if (entries.length > 1) {
      console.log(`  • ${displayPath}`);
    }

    const audioForTranscription =
      entry.audioForTranscription || entry.inputVideo;

    try {
      const baseDirForTranscript = transcriptDirOption
        ? path.resolve(transcriptDirOption)
        : entry.targetDir;

      const resolvedTranscriptOutput = transcriptOutputArg
        ? path.resolve(transcriptOutputArg)
        : null;
      const targetBaseDir = resolvedTranscriptOutput
        ? path.dirname(resolvedTranscriptOutput)
        : baseDirForTranscript;
      const transcriptBaseName = resolvedTranscriptOutput
        ? path.parse(resolvedTranscriptOutput).name
        : entry.targetBaseName;

      const transcriptTargets = transcriptFormats.map((format) => ({
        format,
        path: path.join(targetBaseDir, `${transcriptBaseName}.${format}`),
      }));

      let missingTargets = transcriptTargets;
      if (!force) {
        const checks = await Promise.all(
          transcriptTargets.map((target) => pathExists(target.path)),
        );
        missingTargets = transcriptTargets.filter((_, index) => !checks[index]);
      }

      if (!force && missingTargets.length === 0) {
        transcriptTargets.forEach((target) => {
          console.log(
            `    • Transcript already exists at ${target.path}; skipping (delete or use --force to regenerate).`,
          );
        });
        entry.summary.transcript = {
          outputs: transcriptTargets.map((target) => ({
            format: target.format,
            path: target.path,
            skipped: true,
            reason: "exists",
          })),
          skipped: true,
          reason: "exists",
          path: transcriptTargets.length
            ? transcriptTargets[0].path
            : undefined,
        };
        recordStageSuccess("transcript");
        continue;
      }

      try {
        const transcriptResult = await transcribeWithWhisper({
          inputPath: audioForTranscription,
          outputDir: transcriptDirOption,
          outputFormats: transcriptFormats,
          model: argv["whisper-model"] || DEFAULT_WHISPER_MODEL,
          language: argv["whisper-language"],
          task: argv["whisper-task"],
          device: argv["whisper-device"],
          computeType: argv["whisper-compute-type"],
          whisperPath: argv["whisper-bin"],
          extraArgs: whisperExtraArgs,
          logger: console,
        });

        const finalOutputs = [];
        for (const target of transcriptTargets) {
          const produced = (transcriptResult.outputs || []).find(
            (item) => item.format === target.format,
          );
          let producedPath = produced
            ? produced.path
            : path.join(
                baseDirForTranscript,
                `${transcriptBaseName}.${target.format}`,
              );
          const resolvedProducedPath = path.resolve(producedPath);
          const resolvedTargetPath = path.resolve(target.path);

          if (resolvedProducedPath !== resolvedTargetPath) {
            await fs.promises.mkdir(path.dirname(resolvedTargetPath), {
              recursive: true,
            });
            if (force) {
              try {
                await fs.promises.unlink(resolvedTargetPath);
              } catch (unlinkErr) {
                if (unlinkErr.code !== "ENOENT") throw unlinkErr;
              }
            }
            if (await pathExists(resolvedProducedPath)) {
              await fs.promises.rename(
                resolvedProducedPath,
                resolvedTargetPath,
              );
              producedPath = resolvedTargetPath;
            }
          }

          if (await pathExists(path.resolve(producedPath))) {
            finalOutputs.push({
              format: target.format,
              path: path.resolve(producedPath),
            });
          }
        }

        finalOutputs.forEach((output, index) => {
          if (index === 0) {
            console.log(
              `    ✓ Transcript saved to ${output.path} [${output.format}]`,
            );
          } else {
            console.log(`      • ${output.path} [${output.format}]`);
          }
        });

        entry.summary.transcript = {
          outputs: finalOutputs,
          flavor: transcriptResult.flavor,
          path: finalOutputs.length ? finalOutputs[0].path : undefined,
        };
        recordStageSuccess("transcript");
      } catch (err) {
        if (err && err.code === "WHISPER_NOT_FOUND") {
          console.warn(
            "    ⚠ Whisper CLI not found; transcription skipped. Install openai-whisper or faster-whisper, or pass --skip-transcript to silence this message.",
          );
          recordStageFailure(entry, "transcript", "Whisper CLI not found", {
            reason: "whisper-not-found",
          });
        } else {
          throw err;
        }
      }
    } catch (err) {
      const resolved = resolveErrorMessage(
        err,
        `Transcription failed for ${displayPath}`,
      );
      console.error(`    ✗ Transcription failed: ${resolved}`);
      recordStageFailure(entry, "transcript", resolved);
      continue;
    } finally {
      await updateRunLog();
    }
  }
}

async function processCompressionStage(entries, argv, force) {
  const skipCompress = Boolean(argv["skip-compress"] || argv.skipCompress);

  if (skipCompress) {
    console.log("[3/3] Compression skipped.");
    entries.forEach((entry) => {
      if (entry && entry.summary) {
        entry.summary.compression = { skipped: true };
      }
    });
    await updateRunLog();
    return;
  }

  const compressExtraArgs = parseRepeatable(argv["compress-extra"]);
  const label =
    entries.length > 1
      ? "[3/3] Compressing videos for all files..."
      : "[3/3] Compressing video...";
  console.log(label);

  const crfValue = parseNumber(argv["compress-crf"], "--compress-crf") ?? 23;
  const maxHeightValue = parseNumber(
    argv["compress-max-height"],
    "--compress-max-height",
  );
  const compressOutputOption = argv["compress-output"]
    ? path.resolve(argv["compress-output"])
    : null;
  let presetValue = argv["compress-preset"];
  if (presetValue === undefined || presetValue === null) {
    presetValue = "medium";
  } else {
    presetValue = `${presetValue}`.trim() || "medium";
  }
  const presetLabel = presetValue.replace(/\s+/g, "-");

  for (const entry of entries) {
    if (!entry || !entry.summary) continue;
    const displayPath = formatDisplayPath(entry.inputVideo);
    if (entries.length > 1) {
      console.log(`  • ${displayPath}`);
    }

    try {
      try {
        const compressResult = await compressVideo({
          inputPath: entry.inputVideo,
          outputPath:
            compressOutputOption ||
            `${entry.targetBasePath}.compressed.${presetLabel}.mp4`,
          force,
          crf: crfValue,
          preset: presetValue,
          audioBitrate: argv["compress-audio-bitrate"] || "128k",
          videoCodec: argv["compress-video-codec"] || "libx264",
          audioCodec: argv["compress-audio-codec"] || "aac",
          pixelFormat: argv["compress-pix-format"] || "yuv420p",
          keepResolution: Boolean(argv["compress-keep-resolution"]),
          maxHeight: maxHeightValue,
          tune: argv["compress-tune"],
          extraArgs: compressExtraArgs,
          ffmpegPath: argv.ffmpeg,
          logger: console,
        });
        entry.summary.compression = compressResult;
        console.log(`    ✓ Video saved to ${compressResult.outputPath}`);
        recordStageSuccess("compression");
      } catch (err) {
        if (err && err.code === "OUTPUT_EXISTS" && !force) {
          const existingOutput = outputExistsPathFromError(err);
          entry.summary.compression = {
            skipped: true,
            reason: "exists",
            outputPath: existingOutput,
          };
          if (existingOutput) {
            console.log(
              `    • Compressed video already exists at ${existingOutput}; skipping (use --force to regenerate).`,
            );
          } else {
            console.log(
              "    • Compressed video output already exists; skipping (use --force to regenerate).",
            );
          }
          recordStageSuccess("compression");
        } else {
          throw err;
        }
      }
    } catch (err) {
      const resolved = resolveErrorMessage(
        err,
        `Compression failed for ${displayPath}`,
      );
      console.error(`    ✗ Compression failed: ${resolved}`);
      recordStageFailure(entry, "compression", resolved);
      continue;
    } finally {
      await updateRunLog();
    }
  }
}

async function processEntrySequentially(entry, argv, force) {
  await processAudioStage([entry], argv, force);
  await processTranscriptionStage([entry], argv, force);
  await processCompressionStage([entry], argv, force);
}

async function writeRunLog(entries, options = {}) {
  const { fatalError } = options;
  if (fatalError) {
    runStatistics.fatalError = resolveErrorMessage(
      fatalError,
      fatalError && fatalError.message
        ? fatalError.message
        : "Unknown fatal error",
    );
  }

  const lines = [];
  lines.push(`# videos_normalize run - ${new Date().toISOString()}`);
  lines.push(`files_processed=${entries.length}`);
  lines.push("");
  lines.push("Stage results:");
  STAGE_KEYS.forEach((key) => {
    const bucket = runStatistics.stages[key] || { success: 0, errors: 0 };
    lines.push(`- ${key}: success=${bucket.success} error=${bucket.errors}`);
  });

  lines.push("");
  if (runStatistics.errors.length) {
    lines.push("Errors:");
    runStatistics.errors.forEach((entry, index) => {
      lines.push(`${index + 1}. ${entry}`);
    });
  } else {
    lines.push("Errors: none");
  }

  if (runStatistics.fatalError) {
    lines.push("");
    lines.push(`Fatal error: ${runStatistics.fatalError}`);
  }

  lines.push("");

  try {
    await fs.promises.writeFile(
      runLogFilePath,
      `${lines.join("\n")}\n`,
      "utf8",
    );
  } catch (err) {
    console.error(
      `⚠ Failed to write log file at ${runLogFilePath}: ${resolveErrorMessage(err)}`,
    );
  }
}

async function main() {
  const parser = yargs(process.argv.slice(2))
    .parserConfiguration({
      "camel-case-expansion": true,
      "duplicate-arguments-array": true,
      "flatten-duplicate-arrays": false,
      "strip-aliased": true,
    })
    .help(false)
    .version(false)
    .alias("h", "help")
    .option("audio-output", { type: "string" })
    .option("audio-format", { type: "string" })
    .option("audio-stream", { type: "string" })
    .option("audio-bitrate", { type: "string" })
    .option("audio-sample-rate", { type: "string" })
    .option("audio-source", { type: "string" })
    .option("transcript-dir", { type: "string" })
    .option("transcript-output", { type: "string" })
    .option("transcript-format", { type: "string" })
    .option("whisper-model", { type: "string" })
    .option("whisper-language", { type: "string" })
    .option("whisper-task", { type: "string" })
    .option("whisper-device", { type: "string" })
    .option("whisper-compute-type", { type: "string" })
    .option("whisper-bin", { type: "string" })
    .option("whisper-extra", { type: "array" })
    .option("compress-output", { type: "string" })
    .option("compress-crf", { type: "string" })
    .option("compress-preset", { type: "string" })
    .option("compress-audio-bitrate", { type: "string" })
    .option("compress-video-codec", { type: "string" })
    .option("compress-audio-codec", { type: "string" })
    .option("compress-pix-format", { type: "string" })
    .option("compress-max-height", { type: "string" })
    .option("compress-tune", { type: "string" })
    .option("compress-extra", { type: "array" })
    .option("ffmpeg", { type: "string" })
    .option("ffprobe", { type: "string" })
    .option("job-mode", { type: "string" })
    .option("input", { type: "string" })
    .boolean([
      "help",
      "skip-audio",
      "skip-transcript",
      "skip-compress",
      "force",
      "compress-keep-resolution",
      "trash-input",
    ])
    .coerce("whisper-extra", coerceArrayOfStrings)
    .coerce("compress-extra", coerceArrayOfStrings)
    .wrap(null);

  const argv = parser.parse();

  if (argv.help) {
    showHelp();
    return;
  }

  const rawJobMode = argv["job-mode"] || argv.jobMode;
  const jobMode = rawJobMode
    ? String(rawJobMode).toLowerCase()
    : DEFAULT_JOB_MODE;
  if (!JOB_MODE_VALUES.has(jobMode)) {
    console.error("Error: --job-mode must be either 'step' or 'file'.");
    process.exit(1);
  }

  const rawInputs = argv._.length ? argv._ : argv.input ? [argv.input] : [];
  if (!rawInputs.length) {
    console.error("Error: input video file is required.");
    showHelp();
    process.exit(1);
  }

  const resolvedInputs = rawInputs.map((item) => path.resolve(item));
  if (runLogFilePath) {
    console.log(`Run log will be written to ${runLogFilePath}`);
  }
  const entrySpecs = [];

  for (const candidate of resolvedInputs) {
    let stats;
    try {
      stats = await fs.promises.stat(candidate);
    } catch (err) {
      if (err && err.code === "ENOENT") {
        const ext = path.extname(candidate).toLowerCase();
        if (VIDEO_EXTENSIONS.has(ext)) {
          try {
            const fallback = await findCompressedFallback(candidate);
            if (fallback) {
              entrySpecs.push({
                requestedPath: candidate,
                actualPath: fallback,
                usedFallback: true,
              });
              continue;
            }
          } catch (fallbackErr) {
            console.error(
              `Error searching for compressed fallback: ${candidate}`,
            );
            if (fallbackErr && fallbackErr.message) {
              console.error(fallbackErr.message);
            }
            process.exit(1);
          }
        }
        console.error(`Error accessing input path: ${candidate}`);
        console.error(`File not found: ${candidate}`);
        process.exit(1);
      }
      console.error(`Error accessing input path: ${candidate}`);
      if (err && err.message) {
        console.error(err.message);
      }
      process.exit(1);
    }

    if (stats.isDirectory()) {
      let videoFiles;
      try {
        videoFiles = await listVideoFilesRecursive(candidate);
      } catch (dirErr) {
        console.error(`Error reading directory: ${candidate}`);
        if (dirErr && dirErr.message) {
          console.error(dirErr.message);
        }
        process.exit(1);
      }
      if (!videoFiles.length) {
        console.error(
          `Error: directory contains no supported video files: ${candidate}`,
        );
        process.exit(1);
      }
      for (const filePath of videoFiles) {
        entrySpecs.push({
          requestedPath: filePath,
          actualPath: filePath,
          usedFallback: false,
        });
      }
      continue;
    }

    if (stats.isFile()) {
      entrySpecs.push({
        requestedPath: candidate,
        actualPath: candidate,
        usedFallback: false,
      });
      continue;
    }

    console.error(`Error: unsupported input type: ${candidate}`);
    process.exit(1);
  }

  if (entrySpecs.length > 1) {
    const singleOnlyOptions = [
      ["audio-output", "audioOutput"],
      ["audio-source", "audioSource"],
      ["transcript-output", "transcriptOutput"],
      ["compress-output", "compressOutput"],
    ];

    for (const names of singleOnlyOptions) {
      if (optionProvided(argv, ...names)) {
        console.error(
          `Error: --${names[0]} can only be used when processing a single input file.`,
        );
        process.exit(1);
      }
    }
  }

  const force = Boolean(argv.force);
  const trashInput = Boolean(argv["trash-input"] || argv.trashInput);

  const entries = [];
  const seenJobTargets = new Map();

  for (const spec of entrySpecs) {
    const actualPath = path.resolve(spec.actualPath);
    const requestedPath = path.resolve(spec.requestedPath);

    try {
      await ensureReadable(actualPath, "Input video");
      const fileStats = await fs.promises.stat(actualPath);
      if (!fileStats.isFile()) {
        console.error(
          `Error: expected a video file but got a directory: ${actualPath}`,
        );
        process.exit(1);
      }
    } catch (err) {
      console.error(
        err && err.message
          ? err.message
          : `Input video not accessible: ${actualPath}`,
      );
      process.exit(1);
    }

    const referencePath = spec.usedFallback ? requestedPath : actualPath;
    const referenceDir = path.dirname(referencePath);
    const referenceExt = path.extname(referencePath);
    let referenceBase = path.basename(referencePath, referenceExt);
    if (!referenceBase) {
      referenceBase = path.basename(actualPath, path.extname(actualPath));
    }
    const targetBasePath = path.join(referenceDir, referenceBase);

    const dedupeKey = path.resolve(targetBasePath);
    if (!force && seenJobTargets.has(dedupeKey)) {
      const previous = seenJobTargets.get(dedupeKey);
      const currentLabel = formatDisplayPath(requestedPath);
      const previousLabel = formatDisplayPath(previous.requestedPath);
      console.log(
        `Skipping duplicate job for ${currentLabel}; already scheduled for ${previousLabel}. Use --force to rerun.`,
      );
      continue;
    }

    const entry = {
      inputVideo: actualPath,
      requestedVideo: requestedPath,
      usedFallback: Boolean(spec.usedFallback),
      targetDir: referenceDir,
      targetBaseName: referenceBase,
      targetBasePath,
      summary: {
        inputVideo: requestedPath,
        sourceVideo: actualPath,
      },
    };

    if (entry.usedFallback) {
      entry.summary.fallback = {
        requested: requestedPath,
        source: actualPath,
      };
    }

    seenJobTargets.set(dedupeKey, {
      requestedPath,
      actualPath,
    });

    entries.push(entry);
  }

  for (const entry of entries) {
    if (entry.usedFallback) {
      const missingDisplay = formatDisplayPath(entry.requestedVideo);
      const replacementDisplay = formatDisplayPath(entry.inputVideo);
      console.warn(
        `⚠ Raw video missing at ${missingDisplay}; using compressed file ${replacementDisplay}.`,
      );
    }
  }

  currentRunEntries = entries;
  await updateRunLog();

  try {
    if (jobMode === JOB_MODE_FILE) {
      for (let index = 0; index < entries.length; index += 1) {
        const entry = entries[index];
        if (entries.length > 1) {
          const displayTarget = formatDisplayPath(
            entry.requestedVideo || entry.inputVideo,
          );
          console.log("");
          console.log(
            `Processing file (${index + 1}/${entries.length}): ${displayTarget}`,
          );
        }
        await processEntrySequentially(entry, argv, force);
      }
    } else {
      await processAudioStage(entries, argv, force);
      await processTranscriptionStage(entries, argv, force);
      await processCompressionStage(entries, argv, force);
    }
  } catch (err) {
    console.error("");
    console.error(`Failed: ${err.message}`);
    await writeRunLog(entries, { fatalError: err });
    process.exit(1);
  }

  const summaries = [];

  for (const entry of entries) {
    const summary = entry.summary;
    if (trashInput) {
      try {
        const trashedPath = await moveToTrash(entry.inputVideo);
        const displayPath = formatDisplayPath(trashedPath);
        summary.original = {
          trashed: true,
          trashPath: trashedPath,
        };
        console.log(`  Original:   moved to trash -> ${displayPath}`);
      } catch (trashErr) {
        console.warn(
          `  ⚠ Failed to move original video to trash: ${trashErr.message}`,
        );
        summary.original = {
          trashed: false,
          error: trashErr.message,
        };
      }
    }
    summaries.push(summary);
  }

  if (summaries.length > 1) {
    console.log("");
    console.log(`Processed ${summaries.length} files:`);
    for (const item of summaries) {
      console.log(`  - ${item.inputVideo}`);
      if (item.fallback && item.fallback.source) {
        console.log(
          `      Fallback: used ${formatDisplayPath(item.fallback.source)}`,
        );
      }
      if (item.audio && item.audio.outputPath) {
        const suffix =
          item.audio.skipped && item.audio.reason === "exists"
            ? " (already exists)"
            : "";
        console.log(`      Audio: ${item.audio.outputPath}${suffix}`);
      } else if (item.audio && item.audio.skipped) {
        const reason = describeSkipReason(item.audio.reason);
        const detail = item.audio.error ? ` - ${item.audio.error}` : "";
        console.log(
          `      Audio: skipped${reason ? ` (${reason})` : ""}${detail}`,
        );
      }
      if (
        item.transcript &&
        item.transcript.outputs &&
        item.transcript.outputs.length
      ) {
        const parts = item.transcript.outputs.map((output) => {
          const suffix =
            output.skipped && output.reason === "exists"
              ? " (already exists)"
              : "";
          const label = output.format ? ` [${output.format}]` : "";
          return `${output.path}${suffix}${label}`;
        });
        console.log(`      Transcript: ${parts.join(", ")}`);
      } else if (item.transcript && item.transcript.path) {
        const suffix =
          item.transcript.skipped && item.transcript.reason === "exists"
            ? " (already exists)"
            : "";
        console.log(`      Transcript: ${item.transcript.path}${suffix}`);
      } else if (item.transcript && item.transcript.skipped) {
        const reason = describeSkipReason(item.transcript.reason) || "skipped";
        const detail = item.transcript.error
          ? ` - ${item.transcript.error}`
          : "";
        console.log(`      Transcript: ${reason}${detail}`);
      }
      if (item.compression && item.compression.outputPath) {
        const suffix =
          item.compression.skipped && item.compression.reason === "exists"
            ? " (already exists)"
            : "";
        console.log(`      Video: ${item.compression.outputPath}${suffix}`);
      } else if (item.compression && item.compression.skipped) {
        const reason = describeSkipReason(item.compression.reason);
        const detail = item.compression.error
          ? ` - ${item.compression.error}`
          : "";
        console.log(
          `      Video: skipped${reason ? ` (${reason})` : ""}${detail}`,
        );
      }
      if (item.original) {
        if (item.original.trashed && item.original.trashPath) {
          console.log(
            `      Original: trashed -> ${formatDisplayPath(item.original.trashPath)}`,
          );
        } else if (item.original.error) {
          console.log(`      Original: trash failed (${item.original.error})`);
        }
      }
    }
  }

  await writeRunLog(entries);
}

main();
