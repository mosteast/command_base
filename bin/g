#!/usr/bin/env bash

set -euo pipefail

script_name=$(basename "$0")
script_version="0.1.0"

GREEN=$'\033[32m'
YELLOW=$'\033[33m'
BLUE=$'\033[34m'
RED=$'\033[31m'
RESET=$'\033[0m'

LEVEL_ERROR=0
LEVEL_WARN=1
LEVEL_INFO=2
LEVEL_DEBUG=3

log_threshold=$LEVEL_INFO
dry_run=false
has_staged_changes=false
has_branch_ahead=false
has_upstream=false
merge_in_progress=false

handle_error() {
  local exit_code=$?
  if [ "$exit_code" -ne 0 ]; then
    log_error "Execution failed with exit code ${exit_code}."
  fi
  exit "$exit_code"
}
trap handle_error ERR

print_help() {
  cat <<EOF
Usage: ${script_name} [options] [commit message]

Description:
  Stage all changes, create a commit, and push the current branch to its configured upstream.

Options:
  -h, --help        Show this help message and exit.
  -v, --version     Show the version number and exit.
  --debug           Print verbose debug logs.
  --quiet           Print only warnings and errors.
  -d, --dry-run     Print the planned actions without executing them.

Examples:
  # Commit all changes with a custom message
  \$0 "Add payment gateway integration"

  # Preview actions without committing or pushing
  \$0 --dry-run

  # Commit using a UTC timestamp as the message with debug logs
  \$0 --debug
EOF
}

print_version() {
  echo "${script_version}"
}

log_emit() {
  local level=$1
  local color=$2
  local label=$3
  shift 3
  local message="$*"

  if [ "$log_threshold" -lt "$level" ]; then
    return 0
  fi

  >&2 printf "%b[%s]%b %s\n" "$color" "$label" "$RESET" "$message"
}

log_error() {
  log_emit "$LEVEL_ERROR" "$RED" "ERROR" "$*"
}

log_warn() {
  log_emit "$LEVEL_WARN" "$YELLOW" "WARN" "$*"
}

log_info() {
  log_emit "$LEVEL_INFO" "$GREEN" "INFO" "$*"
}

log_debug() {
  log_emit "$LEVEL_DEBUG" "$BLUE" "DEBUG" "$*"
}

format_command() {
  local formatted=""
  local arg
  for arg in "$@"; do
    formatted+=$(printf '%q ' "$arg")
  done
  printf "%s" "${formatted% }"
}

ensure_dependency() {
  local dependency=$1
  log_debug "Verifying dependency: ${dependency}"
  if ! which "$dependency" >/dev/null 2>&1; then
    log_error "Required dependency '${dependency}' is not installed or not on PATH."
    exit 1
  fi
}

execute_step() {
  local description=$1
  shift
  local command_str
  command_str=$(format_command "$@")
  log_debug "${description}"
  log_debug "Command: ${command_str}"

  if [ "$dry_run" = true ]; then
    log_info "Dry run: ${command_str}"
    return 0
  fi

  "$@"
}

verify_git_repository() {
  log_debug "Checking if current directory is inside a Git repository."
  log_debug "Command: git rev-parse --is-inside-work-tree"
  if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    log_error "This command must be run inside a Git repository."
    exit 1
  fi
}

detect_merge_in_progress() {
  log_debug "Checking for ongoing merge."
  log_debug "Command: git rev-parse -q --verify MERGE_HEAD"
  if git rev-parse -q --verify MERGE_HEAD >/dev/null 2>&1; then
    merge_in_progress=true
    log_debug "Merge in progress detected (MERGE_HEAD present)."
  else
    merge_in_progress=false
    log_debug "No merge in progress."
  fi
}

collect_commit_message() {
  local provided_message=$1
  if [ -n "$provided_message" ]; then
    echo "$provided_message"
    return
  fi

  if [ "$merge_in_progress" = true ]; then
    log_info "Merge in progress; using existing merge commit message."
    echo ""
    return
  fi

  log_debug "No commit message provided; generating UTC timestamp."
  log_debug 'Command: date -u +"%Y-%m-%dT%H:%M:%SZ"'
  date -u +"%Y-%m-%dT%H:%M:%SZ"
}

assess_repository_state() {
  has_staged_changes=false
  has_branch_ahead=false
  has_upstream=false

  log_debug "Assessing repository state after staging."
  log_debug "Command: git diff --cached --quiet --ignore-submodules --exit-code"
  if ! git diff --cached --quiet --ignore-submodules --exit-code; then
    has_staged_changes=true
    log_debug "Staged changes detected."
  else
    log_debug "No staged changes detected."
  fi

  log_debug "Command: git diff --quiet --ignore-submodules --exit-code"
  if ! git diff --quiet --ignore-submodules --exit-code; then
    log_warn "Unstaged changes remain after staging. Review required before committing."
  fi

  log_debug "Command: git rev-parse --abbrev-ref --symbolic-full-name @{u}"
  if git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1; then
    has_upstream=true
    log_debug "Command: git rev-list --left-right --count @{u}...HEAD"
    local ahead_output
    ahead_output=$(git rev-list --left-right --count "@{u}...HEAD")
    local ahead_count=""
    read -r _ ahead_count <<<"$ahead_output"
    if [ -n "$ahead_count" ] && [ "$ahead_count" -gt 0 ]; then
      has_branch_ahead=true
      log_debug "HEAD is ahead of upstream by ${ahead_count} commits."
    else
      log_debug "HEAD is not ahead of upstream."
    fi
  else
    log_warn "Current branch has no upstream configured."
  fi

  if [ "$has_staged_changes" = false ] && [ "$has_upstream" = true ] && [ "$has_branch_ahead" = false ]; then
    if [ "$merge_in_progress" = true ]; then
      log_warn "Merge in progress with no staged changes detected; attempting commit anyway."
      return
    fi
    log_warn "No staged changes and branch is up to date with upstream; nothing to do."
    exit 0
  fi
}

get_current_branch() {
  log_debug "Command: git rev-parse --abbrev-ref HEAD"
  git rev-parse --abbrev-ref HEAD
}

detect_default_remote() {
  log_debug "Detecting default Git remote."
  log_debug "Command: git remote"
  local remote_list
  remote_list=$(git remote)
  if [ -z "$remote_list" ]; then
    log_error "No Git remotes configured; cannot push."
    exit 1
  fi

  if printf '%s\n' "$remote_list" | grep -qx 'origin'; then
    log_debug "Using remote 'origin'."
    echo "origin"
    return
  fi

  local selected_remote
  selected_remote=$(printf '%s\n' "$remote_list" | head -n 1)
  if [ -z "$selected_remote" ]; then
    log_error "Failed to determine a Git remote."
    exit 1
  fi
  log_warn "Remote 'origin' not found; using '${selected_remote}'."
  echo "$selected_remote"
}

commit_changes() {
  local message=$1

  if [ "$merge_in_progress" = true ] && [ -z "$message" ]; then
    execute_step "Creating merge commit using existing message." git commit --no-edit
  else
    execute_step "Creating commit." git commit -m "$message"
  fi
}

push_changes() {
  log_debug "Determining current branch for push."
  local current_branch
  current_branch=$(get_current_branch)
  log_debug "Command: git rev-parse --abbrev-ref --symbolic-full-name @{u}"
  if git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1; then
    log_debug "Branch '${current_branch}' already has an upstream configured."
    execute_step "Pushing branch '${current_branch}' to its upstream." git push
    log_info "Branch '${current_branch}' pushed successfully."
  else
    log_warn "Branch '${current_branch}' has no upstream configured."
    local remote
    remote=$(detect_default_remote)
    execute_step "Pushing branch '${current_branch}' to '${remote}' and setting upstream." git push --set-upstream "$remote" "$current_branch"
    log_info "Branch '${current_branch}' pushed and upstream set to '${remote}/${current_branch}'."
  fi
}

run() {
  local commit_message_input=""
  local -a positional=()

  while (($#)); do
    case "$1" in
      -h|--help)
        print_help
        exit 0
        ;;
      -v|--version)
        print_version
        exit 0
        ;;
      --debug)
        log_threshold=$LEVEL_DEBUG
        shift
        ;;
      --quiet)
        log_threshold=$LEVEL_WARN
        shift
        ;;
      -d|--dry-run)
        dry_run=true
        shift
        ;;
      --)
        shift
        while (($#)); do
          positional+=("$1")
          shift
        done
        ;;
      -*)
        log_error "Unknown option: $1"
        exit 1
        ;;
      *)
        positional+=("$1")
        shift
        ;;
    esac
  done

  if [ "${#positional[@]}" -gt 0 ]; then
    commit_message_input="${positional[*]}"
  fi

  ensure_dependency git
  ensure_dependency date
  verify_git_repository
  detect_merge_in_progress

  execute_step "Staging all changes." git add --all

  assess_repository_state

  local commit_message
  commit_message=$(collect_commit_message "$commit_message_input")
  if [ "$merge_in_progress" = true ] && [ -z "$commit_message" ]; then
    log_info "Using merge message from MERGE_MSG."
  else
    log_info "Using commit message: ${commit_message}"
  fi

  if [ "$dry_run" = true ]; then
    log_debug "Dry-run mode active; reporting intended actions."
    if [ "$has_staged_changes" = true ] || [ "$merge_in_progress" = true ]; then
      if [ "$merge_in_progress" = true ] && [ -z "$commit_message" ]; then
        log_info "Dry run: $(format_command git commit --no-edit)"
      else
        log_info "Dry run: $(format_command git commit -m "$commit_message")"
      fi
    else
      log_info "Dry run: no staged changes; commit step skipped."
    fi
    local current_branch
    current_branch=$(get_current_branch)
    if [ "$has_branch_ahead" = true ] || [ "$has_staged_changes" = true ] || [ "$has_upstream" = false ]; then
      log_debug "Branch '${current_branch}' requires a push."
      if [ "$has_upstream" = true ]; then
        log_info "Dry run: $(format_command git push)"
      else
        local remote
        remote=$(detect_default_remote)
        log_info "Dry run: $(format_command git push --set-upstream "$remote" "$current_branch")"
      fi
    else
      log_info "Dry run: branch '${current_branch}' already synced with upstream; push step skipped."
    fi
    return 0
  fi

  if [ "$has_staged_changes" = true ] || [ "$merge_in_progress" = true ]; then
    commit_changes "$commit_message"
  else
    log_info "No staged changes detected; skipping commit."
  fi

  if [ "$has_branch_ahead" = true ] || [ "$has_staged_changes" = true ] || [ "$has_upstream" = false ]; then
    push_changes
  else
    log_info "Branch already synchronized with upstream; skipping push."
  fi
}

run "$@"
