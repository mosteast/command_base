#!/bin/bash

# Initialize variables
CHANNEL_URL=""
PLAYLIST_URL=""
default_output_dir="$HOME/Library/Mobile Documents/com~apple~CloudDocs/main/saved/video/YouTube/%(uploader)s"
OUTPUT_DIR="$default_output_dir"
output_dir_provided=false
VIDEO_URLS=()
ONLY_AUDIO=false
ONLY_SUBTITLE=false
OVERWRITE=false
REFRESH=false
youtube_player_client="web,web_safari,web_embedded"
fallback_player_client="android"
debug_mode=false
quiet_mode=false
dry_run=false
script_version="1.0.4"
yt_dlp_color_policy="always"
yt_dlp_color_opts=(--color "$yt_dlp_color_policy")

cleanup_ready=false
cleanup_target_dir=""

# Retry configuration
retry_attempt_limit=3
retry_delay_seconds=2

# Throttle settings
sleep_subtitles_seconds=2
sleep_interval_seconds=2
max_sleep_interval_seconds=4

# Color codes for output readability
color_reset=$'\033[0m'
color_bold=$'\033[1m'
color_dim=$'\033[2m'
color_green=$'\033[32m'
color_yellow=$'\033[33m'
color_red=$'\033[31m'
color_blue=$'\033[34m'
color_cyan=$'\033[36m'
color_magenta=$'\033[35m'
color_gray=$'\033[90m'

log_with_tag() {
    local tag="$1"
    local tag_color="$2"
    local message_color="$3"
    shift 3
    local message="$*"
    printf "%b[%s]%b %b%s%b\n" "$tag_color" "$tag" "$color_reset" "$message_color" "$message" "$color_reset"
}

log_info() {
    if [ "$quiet_mode" = true ]; then
        return 0
    fi
    log_with_tag "INFO" "${color_bold}${color_blue}" "$color_blue" "$*"
}
log_success() {
    if [ "$quiet_mode" = true ]; then
        return 0
    fi
    log_with_tag "OK" "${color_bold}${color_green}" "$color_green" "$*"
}
log_warn() { log_with_tag "WARN" "${color_bold}${color_yellow}" "$color_yellow" "$*"; }
log_error() { log_with_tag "ERROR" "${color_bold}${color_red}" "$color_red" "$*" >&2; }
log_debug() {
    if [ "$debug_mode" != true ] || [ "$quiet_mode" = true ]; then
        return 0
    fi
    log_with_tag "DEBUG" "${color_bold}${color_magenta}" "${color_dim}${color_magenta}" "$*"
}

log_step() {
    if [ "$debug_mode" != true ] || [ "$quiet_mode" = true ]; then
        return 0
    fi
    log_with_tag "STEP" "${color_bold}${color_cyan}" "$color_cyan" "$*"
}
log_io() {
    if [ "$debug_mode" != true ] || [ "$quiet_mode" = true ]; then
        return 0
    fi
    log_with_tag "IO" "${color_bold}${color_gray}" "${color_dim}${color_gray}" "$*"
}

format_command() {
    local formatted=""
    local arg
    for arg in "$@"; do
        formatted+=$(printf '%q ' "$arg")
    done
    printf "%s" "${formatted% }"
}

expand_tilde_path() {
    local path="$1"
    if [[ "$path" == "~/"* ]]; then
        printf "%s" "${HOME}/${path#~/}"
        return 0
    fi
    if [ "$path" = "~" ]; then
        printf "%s" "$HOME"
        return 0
    fi
    printf "%s" "$path"
}

resolve_cleanup_root() {
    local raw_dir="$1"
    if [ -z "$raw_dir" ]; then
        printf "%s" ""
        return 0
    fi
    local expanded_dir
    expanded_dir=$(expand_tilde_path "$raw_dir")
    local cleanup_root="$expanded_dir"
    while [[ "$cleanup_root" == *"%("* ]]; do
        cleanup_root=$(dirname "$cleanup_root")
    done
    printf "%s" "$cleanup_root"
}

cleanup_zero_byte_files() {
    local target_dir="$1"
    if [ -z "$target_dir" ]; then
        log_warn "Zero-byte cleanup skipped: no target directory."
        return 0
    fi
    if [ "$target_dir" = "/" ] || [ "$target_dir" = "." ]; then
        log_warn "Zero-byte cleanup skipped: unsafe target directory '${target_dir}'."
        return 0
    fi
    if [ ! -d "$target_dir" ]; then
        log_warn "Zero-byte cleanup skipped: directory not found '${target_dir}'."
        return 0
    fi

    log_step "Cleanup zero-byte files"
    log_io "scan zero-byte files in ${target_dir}"
    local removed_count=0
    while IFS= read -r -d '' file_path; do
        removed_count=$((removed_count + 1))
        if [ "$dry_run" = true ]; then
            log_io "dry-run: would remove zero-byte file ${file_path}"
            continue
        fi
        log_io "remove zero-byte file ${file_path}"
        rm -f -- "$file_path"
    done < <(find "$target_dir" -type f -size 0 -print0 2>/dev/null)

    if [ "$removed_count" -eq 0 ]; then
        log_info "No zero-byte files found in '${target_dir}'."
        return 0
    fi

    if [ "$dry_run" = true ]; then
        log_info "Dry-run: would remove ${removed_count} zero-byte file(s) in '${target_dir}'."
        return 0
    fi

    log_success "Removed ${removed_count} zero-byte file(s) from '${target_dir}'."
}

maybe_cleanup_zero_byte_files() {
    if [ "$cleanup_ready" != true ]; then
        return 0
    fi
    cleanup_zero_byte_files "$cleanup_target_dir"
}

trap maybe_cleanup_zero_byte_files EXIT

filter_cookie_incompatible_clients() {
    local raw_clients="$1"
    local -a clients=()
    local -a filtered=()
    local client

    IFS=',' read -r -a clients <<< "$raw_clients"
    for client in "${clients[@]}"; do
        client="${client//[[:space:]]/}"
        if [ -z "$client" ]; then
            continue
        fi
        case "$client" in
            ios|android)
                continue
                ;;
        esac
        filtered+=("$client")
    done

    if [ ${#filtered[@]} -eq 0 ]; then
        printf "%s" ""
        return 0
    fi
    printf "%s" "$(IFS=','; printf "%s" "${filtered[*]}")"
}

resolve_youtube_player_client_for_cookies() {
    local raw_clients="$1"
    local context_label="$2"
    if [ -z "$raw_clients" ]; then
        printf "%s" ""
        return 0
    fi
    local filtered_clients
    filtered_clients=$(filter_cookie_incompatible_clients "$raw_clients")
    if [ "$filtered_clients" != "$raw_clients" ]; then
        if [ -n "$context_label" ]; then
            log_debug "YouTube cookies ${context_label}: drop clients ${raw_clients} -> ${filtered_clients}"
        else
            log_debug "YouTube cookies: drop clients ${raw_clients} -> ${filtered_clients}"
        fi
    fi
    printf "%s" "$filtered_clients"
}

# Function to show usage
show_usage() {
    local script_name
    script_name=$(basename "$0")

    cat <<EOF
${color_blue}Usage:${color_reset}
  ${script_name} -c|--channel <url> [options] [-- yt-dlp options]
  ${script_name} -l|--list <url> [options] [-- yt-dlp options]
  ${script_name} <video_url1> [video_url2...] [output_directory] [-- yt-dlp options]

${color_blue}Description:${color_reset}
  Download videos with yt-dlp from YouTube, Bilibili, or Rumble channels, playlists, or
  individual video URLs. Additional yt-dlp options can be passed after "--".
  Metadata sidecars (info JSON, comments, descriptions, thumbnails, playlist meta) are
  written by default; disable any of them via "--" and yt-dlp's --no-write-* flags.

${color_blue}Options:${color_reset}
  -h, --help              Show this help message and exit
  -v, --version           Show version number and exit
      --debug             Print verbose debug output (default: false)
      --quiet             Print only warnings and errors (default: false)
  -d, --dry-run           Print actions without executing (default: false)
  -c, --channel <url>     Download all videos from a channel (YouTube/Bilibili/Rumble)
  -l, --list <url>        Download all videos from a playlist
  -o, --output <dir>      Specify output directory
  -r, --retry-count <n>   Retry attempts when yt-dlp fails (default: ${retry_attempt_limit})
      --only-audio        Download only audio files (default: false)
      --only-subtitle     Download only subtitle files (default: false)
      --overwrite         Force overwrite existing files (default: false)
      --refresh           Clear cached archive for the provided URLs before downloading (default: false)
      --youtube-client    YouTube player clients for yt-dlp (comma-separated, default: ${youtube_player_client})
      --fallback-client   Fallback clients for YouTube format/player errors (default: ${fallback_player_client})
                         Use 'none' to disable fallback.
      --                 Pass additional options to yt-dlp

${color_blue}Examples:${color_reset}
  # Download a YouTube channel
  \$0 -c https://www.youtube.com/@user1

  # Download a Bilibili space
  \$0 -c https://space.bilibili.com/39449692

  # Download a Rumble channel
  \$0 -c https://rumble.com/c/m16

  # Download a playlist with extra yt-dlp options
  \$0 -l https://www.youtube.com/playlist?list=xxx -- --dateafter 20240101

  # Download multiple videos into a custom folder
  \$0 https://youtu.be/xxx https://youtu.be/yyy ~/Downloads/YouTube

${color_yellow}Note:${color_reset} Use exactly one input type (channel, playlist, or video URLs).
EOF
}

detect_platform() {
    local url="$1"
    if [[ "$url" == *"youtube.com"* || "$url" == *"youtu.be"* ]]; then
        printf "youtube"
        return 0
    fi
    if [[ "$url" == *"bilibili.com"* || "$url" == *"b23.tv"* ]]; then
        printf "bilibili"
        return 0
    fi
    if [[ "$url" == *"rumble.com"* ]]; then
        printf "rumble"
        return 0
    fi
    printf "generic"
}

resolve_default_output_dir() {
    local platform="$1"
    case "$platform" in
        youtube)
            printf "%s" "$default_output_dir"
            ;;
        bilibili)
            printf "%s" "${default_output_dir/YouTube/Bilibili}"
            ;;
        rumble)
            printf "%s" "${default_output_dir/YouTube/Rumble}"
            ;;
        *)
            printf "%s" "$default_output_dir"
            ;;
    esac
}

normalize_channel_url() {
    local url="$1"
    local platform="$2"
    local base
    local query

    case "$platform" in
        youtube)
            if [[ "$url" == *"@"* && "$url" != */videos && "$url" != */videos/ ]]; then
                url="${url%/}/videos"
            fi
            ;;
        bilibili)
            if [[ "$url" == *"space.bilibili.com"* ]]; then
                base="$url"
                query=""
                if [[ "$base" == *"?"* ]]; then
                    query="${base#*\?}"
                    base="${base%%\?*}"
                fi
                if [[ "$base" != */video && "$base" != */video/ ]]; then
                    base="${base%/}/video"
                fi
                if [ -n "$query" ]; then
                    url="${base}?${query}"
                else
                    url="$base"
                fi
            fi
            ;;
    esac

    printf "%s" "$url"
}

contains_non_ascii() {
    local input_text="$1"
    if [ -z "$input_text" ]; then
        return 1
    fi
    LC_ALL=C printf '%s' "$input_text" | grep -q '[^ -~]'
}

encode_url_for_http() {
    local raw_url="$1"

    if ! contains_non_ascii "$raw_url"; then
        printf "%s" "$raw_url"
        return 0
    fi

    if command -v python3 >/dev/null 2>&1; then
        if python3 - "$raw_url" <<'PY'
import sys
import urllib.parse

url = sys.argv[1]
print(urllib.parse.quote(url, safe=":/?#[]@!$&'()*+,;=%"))
PY
        then
            return 0
        fi
    fi

    if command -v python >/dev/null 2>&1; then
        if python - "$raw_url" <<'PY'
import sys
import urllib.parse

url = sys.argv[1]
print(urllib.parse.quote(url, safe=":/?#[]@!$&'()*+,;=%"))
PY
        then
            return 0
        fi
    fi

    if command -v node >/dev/null 2>&1; then
        if node -e 'const url = process.argv[1]; console.log(encodeURI(url));' "$raw_url"; then
            return 0
        fi
    fi

    printf "%s" "$raw_url"
    return 1
}

retry_command() {
    local description="$1"
    shift
    local attempt=1

    if [ "$dry_run" = true ]; then
        log_info "Dry-run: ${description}"
        log_info "Dry-run command: $(format_command "$@")"
        return 0
    fi

    while true; do
        if [ "$debug_mode" = true ] && [ "$quiet_mode" != true ]; then
            log_step "${description} (attempt ${attempt})"
            log_io "$(format_command "$@")"
        fi
        if "$@"; then
            if [ $attempt -gt 1 ]; then
                log_success "${description} succeeded on attempt ${attempt}."
            else
                log_info "${description} completed successfully."
            fi
            return 0
        fi

        local exit_code=$?
        log_warn "${description} failed on attempt ${attempt} (exit code ${exit_code})."

        if (( attempt >= retry_attempt_limit )); then
            log_error "${description} failed after ${retry_attempt_limit} attempts (last exit code ${exit_code})."
            return "$exit_code"
        fi

        attempt=$((attempt + 1))
        log_info "Retrying ${description} (attempt ${attempt} of ${retry_attempt_limit}) after ${retry_delay_seconds}s..."
        sleep "$retry_delay_seconds"
    done
}

yt_dlp_last_format_error=false
yt_dlp_last_player_error=false

yt_dlp_output_has_format_error() {
    local log_file="$1"
    log_io "read yt-dlp log file ${log_file}"
    grep -Eqi "Requested format is not available|Only images are available|No video formats found" "$log_file"
}

yt_dlp_output_has_player_error() {
    local log_file="$1"
    log_io "read yt-dlp log file ${log_file}"
    grep -Eqi "Video player configuration error|Error 153" "$log_file"
}

run_yt_dlp_with_log_internal() {
    local fail_on_detected_error="$1"
    shift
    local log_file
    if [ "$dry_run" = true ]; then
        log_info "Dry-run: $(format_command "$@")"
        yt_dlp_last_format_error=false
        yt_dlp_last_player_error=false
        return 0
    fi

    log_io "create temp yt-dlp log file"
    if ! log_file=$(mktemp -t yt_dlp_log.XXXXXX); then
        log_warn "Unable to create temp log file; running yt-dlp without format detection."
        yt_dlp_last_format_error=false
        yt_dlp_last_player_error=false
        if [ "$debug_mode" = true ] && [ "$quiet_mode" != true ]; then
            log_io "$(format_command "$@")"
        fi
        "$@"
        return $?
    fi

    if [ "$debug_mode" = true ] && [ "$quiet_mode" != true ]; then
        log_io "$(format_command "$@")"
    fi
    "$@" 2>&1 | tee "$log_file"
    local exit_code=${PIPESTATUS[0]}

    yt_dlp_last_format_error=false
    yt_dlp_last_player_error=false
    if yt_dlp_output_has_format_error "$log_file"; then
        yt_dlp_last_format_error=true
        if [ "$fail_on_detected_error" = true ]; then
            exit_code=1
        fi
    fi

    if yt_dlp_output_has_player_error "$log_file"; then
        yt_dlp_last_player_error=true
        if [ "$fail_on_detected_error" = true ]; then
            exit_code=1
        fi
    fi

    log_io "remove temp yt-dlp log file ${log_file}"
    rm -f "$log_file"
    return "$exit_code"
}

run_yt_dlp_with_log() {
    run_yt_dlp_with_log_internal true "$@"
}

run_yt_dlp_with_log_capture() {
    run_yt_dlp_with_log_internal false "$@"
}

run_video_yt_dlp() {
    local url="$1"
    local archive_file="$2"
    local output_dir="$3"
    local use_cookies="$4"
    local player_client="$5"

    local -a yt_dlp_args
    yt_dlp_args=(
        "${yt_dlp_color_opts[@]}"
        "${EMBED_SUBS_OPTS[@]}"
        -o "$output_dir/%(uploader)s - Videos/%(title)s.%(ext)s"
        -N 5
        "${FORMAT_OPTS[@]}"
        "${WRITE_SUBS_OPTS[@]}"
        "${WRITE_META_OPTS[@]}"
        --sub-langs "en,en-US,zh-Hans,zh-Hant,zh-CN,zh"
        --sleep-subtitles "$sleep_subtitles_seconds"
        --continue
    )

    if [ "$OVERWRITE" != true ]; then
        yt_dlp_args+=(--download-archive "$archive_file" --no-overwrites)
    else
        yt_dlp_args+=(--force-overwrites)
    fi

    yt_dlp_args+=(
        --sleep-interval "$sleep_interval_seconds"
        --max-sleep-interval "$max_sleep_interval_seconds"
        --retries 10
        --file-access-retries 5
        --fragment-retries 5
        --exec after_move:"rm -f -- \"%(filepath)s.ytdl\""
    )

    if [ "$use_cookies" = true ]; then
        yt_dlp_args+=(--cookies-from-browser chrome)
    fi

    if [ -n "$player_client" ]; then
        yt_dlp_args+=(--extractor-args "youtube:player_client=${player_client}")
    fi

    if [ ${#match_filter_opts[@]} -gt 0 ]; then
        yt_dlp_args+=("${match_filter_opts[@]}")
    fi

    yt_dlp_args+=(
        --add-header "Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
        --add-header "Accept-Language:en-us,en;q=0.5"
        --add-header "Accept-Encoding:gzip, deflate"
        --add-header "Accept-Charset:ISO-8859-1,utf-8;q=0.7,*;q=0.7"
        --add-header "User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36"
        "${EXTRA_OPTS[@]}"
        "$url"
    )

    run_yt_dlp_with_log yt-dlp "${yt_dlp_args[@]}"
}

download_video_with_fallback() {
    local url="$1"
    local archive_file="$2"
    local output_dir="$3"
    local platform="$4"
    local use_cookies=false
    local player_client=""

    if [ "$platform" = "youtube" ]; then
        use_cookies=true
        player_client="$youtube_cookie_player_client"
    fi

    if run_video_yt_dlp "$url" "$archive_file" "$output_dir" "$use_cookies" "$player_client"; then
        return 0
    fi

    local primary_exit_code=$?
    if [ "$platform" = "youtube" ] && [ -n "$fallback_player_client" ]; then
        if [ "$yt_dlp_last_player_error" = true ]; then
            local cookie_fallback_label="${youtube_cookie_fallback_client:-default}"
            log_warn "Primary download failed due to YouTube player configuration; retrying with '${cookie_fallback_label}'."
            log_step "Fallback download with cookies using ${cookie_fallback_label}"
            if run_video_yt_dlp "$url" "$archive_file" "$output_dir" true "$youtube_cookie_fallback_client"; then
                return 0
            fi
            log_warn "Fallback client '${cookie_fallback_label}' failed with cookies; retrying without cookies."
            log_step "Fallback download without cookies using ${fallback_player_client}"
            run_video_yt_dlp "$url" "$archive_file" "$output_dir" false "$fallback_player_client"
            return $?
        fi

        if [ "$yt_dlp_last_format_error" = true ]; then
            log_warn "Primary download failed due to missing formats; retrying without cookies using '${fallback_player_client}'."
            log_step "Fallback download without cookies using ${fallback_player_client}"
            run_video_yt_dlp "$url" "$archive_file" "$output_dir" false "$fallback_player_client"
            return $?
        fi
    fi

    return "$primary_exit_code"
}

# Parse command line arguments
for arg in "$@"; do
    if [ "$arg" = "--" ]; then
        break
    fi
    case "$arg" in
        --debug)
            debug_mode=true
            ;;
        --quiet)
            quiet_mode=true
            ;;
    esac
done

log_step "Parse command line arguments"
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_usage
            exit 0
            ;;
        -v|--version)
            printf "%s\n" "$script_version"
            exit 0
            ;;
        --debug)
            debug_mode=true
            shift
            ;;
        --quiet)
            quiet_mode=true
            shift
            ;;
        -d|--dry-run)
            dry_run=true
            shift
            ;;
        -c|--channel)
            if [ -n "$2" ]; then
                CHANNEL_URL="$2"
                shift 2
            else
                log_error "Channel URL is required after -c|--channel option."
                show_usage
                exit 1
            fi
            ;;
        -l|--list)
            if [ -n "$2" ]; then
                PLAYLIST_URL="$2"
                shift 2
            else
                log_error "Playlist URL is required after -l|--list option."
                show_usage
                exit 1
            fi
            ;;
        -o|--output)
            if [ -n "$2" ]; then
                OUTPUT_DIR="$2"
                output_dir_provided=true
                shift 2
            else
                log_error "Output directory is required after -o|--output option."
                show_usage
                exit 1
            fi
            ;;
        --retry-count=*)
            retry_value="${1#*=}"
            if [[ "$retry_value" =~ ^[0-9]+$ ]] && (( retry_value > 0 )); then
                retry_attempt_limit="$retry_value"
                shift
            else
                log_error "Retry count must be a positive integer."
                exit 1
            fi
            ;;
        -r|--retry-count)
            if [ -n "$2" ]; then
                retry_value="$2"
                if [[ "$retry_value" =~ ^[0-9]+$ ]] && (( retry_value > 0 )); then
                    retry_attempt_limit="$retry_value"
                    shift 2
                else
                    log_error "Retry count must be a positive integer."
                    exit 1
                fi
            else
                log_error "Retry count value is required after -r|--retry-count option."
                exit 1
            fi
            ;;
        --only-audio)
            ONLY_AUDIO=true
            shift
            ;;
        --only-subtitle)
            ONLY_SUBTITLE=true
            shift
            ;;
        --overwrite)
            OVERWRITE=true
            shift
            ;;
        --refresh)
            REFRESH=true
            shift
            ;;
        --youtube-client=*)
            youtube_player_client="${1#*=}"
            if [ -z "$youtube_player_client" ]; then
                log_error "YouTube player client list cannot be empty."
                exit 1
            fi
            shift
            ;;
        --youtube-client)
            if [ -n "$2" ]; then
                youtube_player_client="$2"
                shift 2
            else
                log_error "YouTube player client list is required after --youtube-client option."
                exit 1
            fi
            ;;
        --fallback-client=*)
            fallback_player_client="${1#*=}"
            shift
            ;;
        --fallback-client)
            if [ -n "$2" ]; then
                fallback_player_client="$2"
                shift 2
            else
                log_error "Fallback client list is required after --fallback-client option."
                exit 1
            fi
            ;;
        --)
            shift
            break
            ;;
        -*)
            log_error "Unknown option: $1"
            show_usage
            exit 1
            ;;
        *)
            # If it's the last argument and there are other video URLs, it *could* be an output directory
            if [[ $# -eq 1 && ${#VIDEO_URLS[@]} -gt 0 ]]; then
                # If the argument contains typical URL patterns, treat as a URL.
                if [[ "$1" == "http"* || "$1" == *".com"* || "$1" == *".be"* || "$1" == *"watch?v="* ]]; then
                    VIDEO_URLS+=("$1")
                else
                    OUTPUT_DIR="$1"
                    output_dir_provided=true
                fi
            else
                VIDEO_URLS+=("$1")
            fi
            shift
            ;;
    esac
done

log_step "Deduplicate video URLs"
if [ ${#VIDEO_URLS[@]} -gt 1 ]; then
    DEDUPED_VIDEO_URLS=()
    for candidate_url in "${VIDEO_URLS[@]}"; do
        if printf '%s\n' "${DEDUPED_VIDEO_URLS[@]}" | grep -Fxq -- "$candidate_url"; then
            log_warn "Skipping duplicate URL in argument list: '${candidate_url}'"
            continue
        fi
        DEDUPED_VIDEO_URLS+=("$candidate_url")
    done
    if [ ${#DEDUPED_VIDEO_URLS[@]} -lt ${#VIDEO_URLS[@]} ]; then
        log_info "Video URL list reduced from ${#VIDEO_URLS[@]} to ${#DEDUPED_VIDEO_URLS[@]} unique entries."
    fi
    VIDEO_URLS=("${DEDUPED_VIDEO_URLS[@]}")
fi

# Validate audio/subtitle options
log_step "Validate audio/subtitle options"
if [ "$ONLY_AUDIO" = true ] && [ "$ONLY_SUBTITLE" = true ]; then
    log_error "Cannot use both --only-audio and --only-subtitle options together."
    exit 1
fi

if [ "$fallback_player_client" = "none" ] || [ "$fallback_player_client" = "off" ]; then
    fallback_player_client=""
fi

# Count how many input types are provided
log_step "Validate input type"
INPUT_COUNT=0
[ -n "$CHANNEL_URL" ] && ((INPUT_COUNT++))
[ -n "$PLAYLIST_URL" ] && ((INPUT_COUNT++))
[ ${#VIDEO_URLS[@]} -gt 0 ] && ((INPUT_COUNT++))

# Validate input
if [ $INPUT_COUNT -eq 0 ]; then
    log_error "No input provided. Please provide one of:"
    log_info "  - Channel URL (-c|--channel)"
    log_info "  - Playlist URL (-l|--list)"
    log_info "  - One or more video URLs"
    log_info ""
    show_usage
    exit 1
elif [ $INPUT_COUNT -gt 1 ]; then
    log_error "Multiple input types provided. Please use only one of:"
    log_info "  - Channel URL (-c|--channel)"
    log_info "  - Playlist URL (-l|--list)"
    log_info "  - One or more video URLs"
    log_info ""
    log_info "Current inputs:"
    [ -n "$CHANNEL_URL" ] && log_info "  Channel URL: '$CHANNEL_URL'"
    [ -n "$PLAYLIST_URL" ] && log_info "  Playlist URL: '$PLAYLIST_URL'"
    [ ${#VIDEO_URLS[@]} -gt 0 ] && log_info "  Video URLs: '${VIDEO_URLS[*]}'"
    exit 1
fi

# All remaining arguments will be passed to yt-dlp
EXTRA_OPTS=("$@")

# Create download archive directory if it doesn't exist
log_step "Prepare download archive directory"
ARCHIVE_DIR="${HOME}/.yt-dlp/archives"
if [ "$dry_run" = true ]; then
    log_info "Dry-run: would ensure archive directory '${ARCHIVE_DIR}'."
else
    log_io "ensure archive directory ${ARCHIVE_DIR}"
    mkdir -p "$ARCHIVE_DIR"
fi

# Set format and additional options based on download type
log_step "Configure format options"
FORMAT_OPTS=()
EMBED_SUBS_OPTS=()
WRITE_SUBS_OPTS=()
WRITE_META_OPTS=(
    --write-info-json
    --write-comments
    --write-description
    --write-playlist-metafiles
    --write-link
)

if [ "$ONLY_AUDIO" = true ]; then
    FORMAT_OPTS=(-f ba)
elif [ "$ONLY_SUBTITLE" = true ]; then
    FORMAT_OPTS=(--skip-download)
    WRITE_SUBS_OPTS=(--write-subs --write-auto-subs)
else
    EMBED_SUBS_OPTS=(--embed-subs)
    WRITE_SUBS_OPTS=(--write-subs --write-auto-subs)
fi

log_step "Normalize YouTube player clients for cookies"
youtube_cookie_player_client=$(resolve_youtube_player_client_for_cookies "$youtube_player_client" "primary")
youtube_cookie_fallback_client=$(resolve_youtube_player_client_for_cookies "$fallback_player_client" "fallback")
youtube_extractor_args=()
if [ -n "$youtube_cookie_player_client" ]; then
    youtube_extractor_args=(--extractor-args "youtube:player_client=${youtube_cookie_player_client}")
fi
youtube_fallback_extractor_args=()
if [ -n "$youtube_cookie_fallback_client" ]; then
    youtube_fallback_extractor_args=(--extractor-args "youtube:player_client=${youtube_cookie_fallback_client}")
fi

# Define match filter that allows Rumble videos to bypass subscription check
# For Rumble videos - no filter, for other extractors - check for subscription requirement
MATCH_FILTER="extractor!='Rumble' & extractor!='RumbleEmbed' & availability!='needs_subscription' | extractor='Rumble' | extractor='RumbleEmbed'"
match_filter_opts=()
if [ -n "$MATCH_FILTER" ]; then
    match_filter_opts=(--match-filter "$MATCH_FILTER")
fi

# Handle channel URL mode
if [ -n "$CHANNEL_URL" ]; then
    log_step "Channel download"
    channel_platform=$(detect_platform "$CHANNEL_URL")
    if [ "$output_dir_provided" != true ]; then
        OUTPUT_DIR=$(resolve_default_output_dir "$channel_platform")
    fi
    cleanup_target_dir=$(resolve_cleanup_root "$OUTPUT_DIR")
    cleanup_ready=true
    log_step "Normalize channel URL"
    CHANNEL_URL=$(normalize_channel_url "$CHANNEL_URL" "$channel_platform")
    channel_referer_opts=()
    if contains_non_ascii "$CHANNEL_URL"; then
        log_warn "Channel URL contains non-ASCII characters; encoding for HTTP requests."
        log_io "encode channel URL for HTTP"
        encoded_url=$(encode_url_for_http "$CHANNEL_URL")
        encode_status=$?
        CHANNEL_URL="$encoded_url"
        if [ $encode_status -ne 0 ] && contains_non_ascii "$CHANNEL_URL"; then
            log_warn "No encoder available; continuing with raw channel URL may trigger yt-dlp errors."
        fi
    fi
    if contains_non_ascii "$CHANNEL_URL"; then
        log_warn "Skipping Referer header because channel URL still contains non-ASCII characters."
    else
        channel_referer_opts=(--referer "$CHANNEL_URL")
    fi

    channel_output_template="$OUTPUT_DIR/%(playlist)s/%(n_entries+1-playlist_index)d.%(title)s.%(ext)s"
    channel_cookie_opts=()
    channel_extractor_opts=()
    channel_fallback_extractor_opts=()
    if [ "$channel_platform" = "youtube" ]; then
        channel_cookie_opts=(--cookies-from-browser chrome)
        channel_extractor_opts=(--extractor-args youtubetab:skip=authcheck "${youtube_extractor_args[@]}")
        if [ -n "$fallback_player_client" ]; then
            channel_fallback_extractor_opts=(--extractor-args youtubetab:skip=authcheck "${youtube_fallback_extractor_args[@]}")
        fi
    else
        channel_output_template="$OUTPUT_DIR/%(title)s.%(ext)s"
    fi

    # Generate a unique archive file name based on the channel URL
    ARCHIVE_FILE="${ARCHIVE_DIR}/$(echo "$CHANNEL_URL" | md5sum | cut -d' ' -f1).txt"

    if [ "$REFRESH" = true ]; then
        if [ -f "$ARCHIVE_FILE" ]; then
            log_info "Refresh requested; clearing archive cache at '$ARCHIVE_FILE'."
            if [ "$dry_run" = true ]; then
                log_info "Dry-run: would remove archive cache at '${ARCHIVE_FILE}'."
            else
                log_io "remove archive cache ${ARCHIVE_FILE}"
                rm -f "$ARCHIVE_FILE"
            fi
        else
            log_warn "Refresh requested but no archive cache found for '$CHANNEL_URL'."
        fi
    fi

    channel_base_args=(
        --playlist-reverse
        "${yt_dlp_color_opts[@]}"
        "${EMBED_SUBS_OPTS[@]}"
        -o "$channel_output_template"
        -N 1
        -i
        "${FORMAT_OPTS[@]}"
        "${WRITE_SUBS_OPTS[@]}"
        "${WRITE_META_OPTS[@]}"
        --sub-langs "en,en-US,zh-Hans,zh-Hant,zh-CN,zh"
        --sleep-subtitles "$sleep_subtitles_seconds"
        --continue
    )
    if [ "$OVERWRITE" != true ]; then
        channel_base_args+=(--download-archive "$ARCHIVE_FILE" --no-overwrites)
    else
        channel_base_args+=(--force-overwrites)
    fi
    channel_tail_args=(
        --sleep-interval "$sleep_interval_seconds"
        --max-sleep-interval "$max_sleep_interval_seconds"
        --retries 10
        --file-access-retries 5
        --fragment-retries 5
        --exec after_move:"rm -f -- \"%(filepath)s.ytdl\""
        "${match_filter_opts[@]}"
        --add-header "Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
        --add-header "Accept-Language:en-us,en;q=0.5"
        --add-header "Accept-Encoding:gzip, deflate"
        --add-header "Accept-Charset:ISO-8859-1,utf-8;q=0.7,*;q=0.7"
        --add-header "User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36"
        "${EXTRA_OPTS[@]}"
    )

    retry_command "Channel download: ${CHANNEL_URL}" run_yt_dlp_with_log_capture yt-dlp \
        "${channel_base_args[@]}" \
        "${channel_cookie_opts[@]}" \
        "${channel_extractor_opts[@]}" \
        "${channel_referer_opts[@]}" \
        "${channel_tail_args[@]}" \
        "$CHANNEL_URL"

    channel_status=$?
    channel_primary_player_error=$yt_dlp_last_player_error
    channel_primary_format_error=$yt_dlp_last_format_error

    if [ "$channel_platform" = "youtube" ] && [ -n "$fallback_player_client" ]; then
        channel_cookie_fallback_label="${youtube_cookie_fallback_client:-default}"
        if [ "$channel_primary_player_error" = true ]; then
            log_warn "YouTube player errors detected; retrying failed items with '${channel_cookie_fallback_label}'."
            log_step "Channel fallback download with cookies using ${channel_cookie_fallback_label}"
            retry_command "Channel fallback download: ${CHANNEL_URL}" run_yt_dlp_with_log_capture yt-dlp \
                "${channel_base_args[@]}" \
                "${channel_cookie_opts[@]}" \
                "${channel_fallback_extractor_opts[@]}" \
                "${channel_referer_opts[@]}" \
                "${channel_tail_args[@]}" \
                "$CHANNEL_URL"
            fallback_status=$?
            if [ "$fallback_status" -ne 0 ]; then
                channel_status=$fallback_status
            fi
            if [ "$yt_dlp_last_player_error" = true ]; then
                log_warn "Fallback client '${channel_cookie_fallback_label}' still hit player errors; retrying without cookies."
                log_step "Channel fallback download without cookies using ${fallback_player_client}"
                retry_command "Channel fallback download without cookies: ${CHANNEL_URL}" run_yt_dlp_with_log_capture yt-dlp \
                    "${channel_base_args[@]}" \
                    "${channel_fallback_extractor_opts[@]}" \
                    "${channel_referer_opts[@]}" \
                    "${channel_tail_args[@]}" \
                    "$CHANNEL_URL"
                fallback_status=$?
                if [ "$fallback_status" -ne 0 ]; then
                    channel_status=$fallback_status
                fi
            fi
        elif [ "$channel_primary_format_error" = true ]; then
            log_warn "Primary download had format errors; retrying without cookies using '${fallback_player_client}'."
            log_step "Channel fallback download without cookies using ${fallback_player_client}"
            retry_command "Channel fallback download without cookies: ${CHANNEL_URL}" run_yt_dlp_with_log_capture yt-dlp \
                "${channel_base_args[@]}" \
                "${channel_fallback_extractor_opts[@]}" \
                "${channel_referer_opts[@]}" \
                "${channel_tail_args[@]}" \
                "$CHANNEL_URL"
            fallback_status=$?
            if [ "$fallback_status" -ne 0 ]; then
                channel_status=$fallback_status
            fi
        fi
    fi

    exit "$channel_status"

# Handle playlist URL mode
elif [ -n "$PLAYLIST_URL" ]; then
    log_step "Playlist download"
    playlist_platform=$(detect_platform "$PLAYLIST_URL")
    if [ "$output_dir_provided" != true ]; then
        OUTPUT_DIR=$(resolve_default_output_dir "$playlist_platform")
    fi
    cleanup_target_dir=$(resolve_cleanup_root "$OUTPUT_DIR")
    cleanup_ready=true
    log_step "Normalize playlist URL"
    if contains_non_ascii "$PLAYLIST_URL"; then
        log_warn "Playlist URL contains non-ASCII characters; encoding for HTTP requests."
        log_io "encode playlist URL for HTTP"
        encoded_url=$(encode_url_for_http "$PLAYLIST_URL")
        encode_status=$?
        PLAYLIST_URL="$encoded_url"
        if [ $encode_status -ne 0 ] && contains_non_ascii "$PLAYLIST_URL"; then
            log_warn "No encoder available; continuing with raw playlist URL may trigger yt-dlp errors."
        fi
    fi

    playlist_output_template="$OUTPUT_DIR/%(playlist)s/%(playlist_index)s.%(title)s.%(ext)s"
    playlist_cookie_opts=()
    playlist_extractor_opts=()
    playlist_fallback_extractor_opts=()
    if [ "$playlist_platform" = "youtube" ]; then
        playlist_cookie_opts=(--cookies-from-browser chrome)
        playlist_extractor_opts=("${youtube_extractor_args[@]}")
        if [ -n "$fallback_player_client" ]; then
            playlist_fallback_extractor_opts=("${youtube_fallback_extractor_args[@]}")
        fi
    else
        playlist_output_template="$OUTPUT_DIR/%(title)s.%(ext)s"
    fi

    # Generate a unique archive file name based on the playlist URL
    ARCHIVE_FILE="${ARCHIVE_DIR}/$(echo "$PLAYLIST_URL" | md5sum | cut -d' ' -f1).txt"

    if [ "$REFRESH" = true ]; then
        if [ -f "$ARCHIVE_FILE" ]; then
            log_info "Refresh requested; clearing archive cache at '$ARCHIVE_FILE'."
            if [ "$dry_run" = true ]; then
                log_info "Dry-run: would remove archive cache at '${ARCHIVE_FILE}'."
            else
                log_io "remove archive cache ${ARCHIVE_FILE}"
                rm -f "$ARCHIVE_FILE"
            fi
        else
            log_warn "Refresh requested but no archive cache found for '$PLAYLIST_URL'."
        fi
    fi

    playlist_base_args=(
        --playlist-reverse
        "${yt_dlp_color_opts[@]}"
        "${EMBED_SUBS_OPTS[@]}"
        -o "$playlist_output_template"
        -N 1
        -i
        "${FORMAT_OPTS[@]}"
        "${WRITE_SUBS_OPTS[@]}"
        "${WRITE_META_OPTS[@]}"
        --sub-langs "en,en-US,en-GB,zh-Hans,zh-Hant,zh-CN,zh"
        --sleep-subtitles "$sleep_subtitles_seconds"
        --continue
    )
    if [ "$OVERWRITE" != true ]; then
        playlist_base_args+=(--download-archive "$ARCHIVE_FILE" --no-overwrites)
    else
        playlist_base_args+=(--force-overwrites)
    fi
    playlist_tail_args=(
        --yes-playlist
        --sleep-interval "$sleep_interval_seconds"
        --max-sleep-interval "$max_sleep_interval_seconds"
        --retries 10
        --file-access-retries 5
        --fragment-retries 5
        --exec after_move:"rm -f -- \"%(filepath)s.ytdl\""
        "${match_filter_opts[@]}"
        --add-header "Accept:text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
        --add-header "Accept-Language:en-us,en;q=0.5"
        --add-header "Accept-Encoding:gzip, deflate"
        --add-header "Accept-Charset:ISO-8859-1,utf-8;q=0.7,*;q=0.7"
        --add-header "User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36"
        "${EXTRA_OPTS[@]}"
    )

    retry_command "Playlist download: ${PLAYLIST_URL}" run_yt_dlp_with_log_capture yt-dlp \
        "${playlist_base_args[@]}" \
        "${playlist_cookie_opts[@]}" \
        "${playlist_extractor_opts[@]}" \
        "${playlist_tail_args[@]}" \
        "$PLAYLIST_URL"

    playlist_status=$?
    playlist_primary_player_error=$yt_dlp_last_player_error
    playlist_primary_format_error=$yt_dlp_last_format_error

    if [ "$playlist_platform" = "youtube" ] && [ -n "$fallback_player_client" ]; then
        playlist_cookie_fallback_label="${youtube_cookie_fallback_client:-default}"
        if [ "$playlist_primary_player_error" = true ]; then
            log_warn "YouTube player errors detected; retrying failed items with '${playlist_cookie_fallback_label}'."
            log_step "Playlist fallback download with cookies using ${playlist_cookie_fallback_label}"
            retry_command "Playlist fallback download: ${PLAYLIST_URL}" run_yt_dlp_with_log_capture yt-dlp \
                "${playlist_base_args[@]}" \
                "${playlist_cookie_opts[@]}" \
                "${playlist_fallback_extractor_opts[@]}" \
                "${playlist_tail_args[@]}" \
                "$PLAYLIST_URL"
            fallback_status=$?
            if [ "$fallback_status" -ne 0 ]; then
                playlist_status=$fallback_status
            fi
            if [ "$yt_dlp_last_player_error" = true ]; then
                log_warn "Fallback client '${playlist_cookie_fallback_label}' still hit player errors; retrying without cookies."
                log_step "Playlist fallback download without cookies using ${fallback_player_client}"
                retry_command "Playlist fallback download without cookies: ${PLAYLIST_URL}" run_yt_dlp_with_log_capture yt-dlp \
                    "${playlist_base_args[@]}" \
                    "${playlist_fallback_extractor_opts[@]}" \
                    "${playlist_tail_args[@]}" \
                    "$PLAYLIST_URL"
                fallback_status=$?
                if [ "$fallback_status" -ne 0 ]; then
                    playlist_status=$fallback_status
                fi
            fi
        elif [ "$playlist_primary_format_error" = true ]; then
            log_warn "Primary download had format errors; retrying without cookies using '${fallback_player_client}'."
            log_step "Playlist fallback download without cookies using ${fallback_player_client}"
            retry_command "Playlist fallback download without cookies: ${PLAYLIST_URL}" run_yt_dlp_with_log_capture yt-dlp \
                "${playlist_base_args[@]}" \
                "${playlist_fallback_extractor_opts[@]}" \
                "${playlist_tail_args[@]}" \
                "$PLAYLIST_URL"
            fallback_status=$?
            if [ "$fallback_status" -ne 0 ]; then
                playlist_status=$fallback_status
            fi
        fi
    fi

    exit "$playlist_status"

# Handle individual video URLs mode
else
    log_step "Manual video download"
    cleanup_target_dir=$(resolve_cleanup_root "$OUTPUT_DIR")
    cleanup_ready=true
    log_step "Normalize manual video URLs"
    normalized_video_urls=()
    for url in "${VIDEO_URLS[@]}"; do
        if contains_non_ascii "$url"; then
            log_warn "Video URL contains non-ASCII characters; encoding for HTTP requests."
            log_io "encode video URL for HTTP"
            encoded_url=$(encode_url_for_http "$url")
            encode_status=$?
            url="$encoded_url"
            if [ $encode_status -ne 0 ] && contains_non_ascii "$url"; then
                log_warn "No encoder available; continuing with raw video URL may trigger yt-dlp errors."
            fi
        fi
        normalized_video_urls+=("$url")
    done
    VIDEO_URLS=("${normalized_video_urls[@]}")
    overall_exit_code=0
    failed_video_urls=()
    expanded_output_dir="${OUTPUT_DIR/#\~/$HOME}"
    [ -z "$expanded_output_dir" ] && expanded_output_dir="manual_video_downloads"
    manual_archive_hash=$(printf "%s" "$expanded_output_dir" | md5sum | cut -d' ' -f1)
    manual_archive_file="${ARCHIVE_DIR}/manual_urls_${manual_archive_hash}.txt"

    if [ "$REFRESH" = true ]; then
        if [ -f "$manual_archive_file" ]; then
            log_info "Refresh requested; clearing archive cache at '${manual_archive_file}'."
            if [ "$dry_run" = true ]; then
                log_info "Dry-run: would remove archive cache at '${manual_archive_file}'."
            else
                log_io "remove archive cache ${manual_archive_file}"
                rm -f "$manual_archive_file"
            fi
        else
            log_warn "Refresh requested but no manual video archive found to clear."
        fi
    fi

    if [ "$OVERWRITE" != true ]; then
        if [ "$dry_run" = true ]; then
            log_info "Dry-run: would create archive cache at '${manual_archive_file}'."
        else
            log_io "create archive cache ${manual_archive_file}"
            touch "$manual_archive_file"
        fi
    fi

    for url in "${VIDEO_URLS[@]}"; do
        url_platform=$(detect_platform "$url")

        if retry_command "Video download: ${url}" download_video_with_fallback "$url" "$manual_archive_file" "$OUTPUT_DIR" "$url_platform"
        then
            :
        else
            download_status=$?
            log_error "Skipping ${url} after ${retry_attempt_limit} failed attempts."
            overall_exit_code=$download_status
            failed_video_urls+=("$url")
            continue
        fi
    done

    if [ ${#failed_video_urls[@]} -gt 0 ]; then
        log_warn "Failed videos after ${retry_attempt_limit} attempts:"
        for failed_url in "${failed_video_urls[@]}"; do
            log_warn "  - ${failed_url}"
        done
    fi

    exit "$overall_exit_code"
fi
