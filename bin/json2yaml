#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const glob = require('glob');
const minimist = require('minimist');
const YAML = require('yaml');

function show_usage(exit_code = 0) {
    const cmd = path.basename(process.argv[1] || 'json2yaml');
    console.log('Usage:');
    console.log(`  ${cmd} <patterns...> [-o|--out <dir>] [-e|--extension <ext>] [--force]`);
    console.log(`  echo '{"a":1}' | ${cmd}`);
    console.log('');
    console.log('Options:');
    console.log('  -o, --out DIR          Output directory (defaults to source dir)');
    console.log('  -e, --extension EXT    Output extension (default: .yaml)');
    console.log('  --force, -F            Overwrite when output exists');
    console.log('  -h, --help             Show this help');
    process.exit(exit_code);
}

function normalize_extension(ext, fallback) {
    if (!ext) return fallback;
    return ext.startsWith('.') ? ext : `.${ext}`;
}

function read_stdin() {
    return new Promise((resolve, reject) => {
        let data = '';
        process.stdin.setEncoding('utf8');
        process.stdin.on('data', (chunk) => (data += chunk));
        process.stdin.on('end', () => resolve(data));
        process.stdin.on('error', (err) => reject(err));
    });
}

function convert_json_text_to_yaml(json_text) {
    const text = json_text && json_text.charCodeAt(0) === 0xfeff ? json_text.slice(1) : json_text;
    const obj = JSON.parse(text);
    // 2-space indent is a sensible default
    return YAML.stringify(obj, { indent: 2 });
}

async function main() {
    const argv = minimist(process.argv.slice(2), {
        boolean: ['help', 'h', 'force', 'F'],
        string: ['out', 'o', 'extension', 'e'],
        alias: { o: 'out', e: 'extension', h: 'help', F: 'force' },
    });

    if (argv.help) show_usage(0);

    const patterns = argv._ || [];

    // STDIN mode: no args or single '-' argument
    const stdin_mode = patterns.length === 0 || (patterns.length === 1 && patterns[0] === '-');
    const output_extension = normalize_extension(argv.extension || argv.e, '.yaml');
    const output_dir_cli = argv.out || argv.o || '';
    const force_overwrite = Boolean(argv.force || argv.F);

    if (stdin_mode) {
        try {
            const input = await read_stdin();
            if (!input || input.trim() === '') {
                // No stdin provided; show help with non-zero exit to indicate misuse
                show_usage(1);
            }
            const yaml_text = convert_json_text_to_yaml(input);
            process.stdout.write(yaml_text);
            return;
        } catch (err) {
            console.error(`Failed to convert from STDIN: ${err.message}`);
            process.exit(1);
        }
    }

    // File/pattern mode
    const files = [];
    for (const pattern of patterns) {
        // Expand glob patterns; if none found, treat as a literal file path
        const matches = glob.sync(pattern, { nodir: true, nocase: false });
        if (matches.length > 0) {
            for (const m of matches) files.push(m);
        } else {
            files.push(pattern);
        }
    }

    if (files.length === 0) {
        console.error('Error: No input files found.');
        show_usage(1);
    }

    let converted_count = 0;
    let failed_count = 0;

    for (const file_path of files) {
        let absolute_input_path = path.resolve(file_path);

        if (!fs.existsSync(absolute_input_path) || !fs.statSync(absolute_input_path).isFile()) {
            console.error(`Skipping (not a file): ${file_path}`);
            continue;
        }

        const source_dir = path.dirname(absolute_input_path);
        const base_name_without_ext = path.basename(absolute_input_path, path.extname(absolute_input_path));

        const output_directory = output_dir_cli ? path.resolve(output_dir_cli) : source_dir;
        const output_path = path.join(output_directory, `${base_name_without_ext}${output_extension}`);

        try {
            if (output_dir_cli) fs.mkdirSync(output_directory, { recursive: true });

            if (fs.existsSync(output_path) && !force_overwrite) {
                console.log(`Exists (skip): ${path.relative(process.cwd(), output_path)}`);
                continue;
            }

            const input_text = fs.readFileSync(absolute_input_path, 'utf8');
            const yaml_text = convert_json_text_to_yaml(input_text);
            fs.writeFileSync(output_path, yaml_text, 'utf8');

            console.log(`Converted: ${path.relative(process.cwd(), absolute_input_path)} -> ${path.relative(process.cwd(), output_path)}`);
            converted_count++;
        } catch (err) {
            console.error(`Error processing ${file_path}: ${err.message}`);
            failed_count++;
        }
    }

    console.log(`Done. Converted: ${converted_count}. Failed: ${failed_count}.`);
}

main(); 