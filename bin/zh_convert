#!/usr/bin/env node

"use strict";

const fs = require("fs/promises");
const path = require("path");
const yargs_factory = require("yargs/yargs");
const { expand_patterns } = require("../utility/_ai_cli_utils");

let chalk = null;
let conversion_runtime = null;

function hide_process_argv(argv) {
  return Array.isArray(argv) ? argv.slice(2) : [];
}

function ensure_chalk() {
  if (chalk) {
    return chalk;
  }
  try {
    // chalk@3 exposes a CommonJS default export
    // eslint-disable-next-line global-require
    chalk = require("chalk");
  } catch (error) {
    throw new Error(`Failed to load chalk for colored output: ${error.message}`);
  }
  return chalk;
}

async function ensure_conversion_runtime() {
  if (conversion_runtime) {
    return conversion_runtime;
  }
  try {
    const module = await import("chinese-conv/dist");
    if (!module || typeof module.sify !== "function" || typeof module.tify !== "function") {
      throw new Error("Unexpected chinese-conv export shape");
    }
    conversion_runtime = {
      to_hans: (input_text) => module.sify(input_text),
      to_hant: (input_text) => module.tify(input_text),
    };
    return conversion_runtime;
  } catch (error) {
    throw new Error(`Failed to initialize chinese-conv: ${error.message}`);
  }
}

async function convert_text_to_hans(input_text) {
  const runtime = await ensure_conversion_runtime();
  return runtime.to_hans(input_text);
}

async function convert_text_to_hant(input_text) {
  const runtime = await ensure_conversion_runtime();
  return runtime.to_hant(input_text);
}

async function read_file_text(file_path, encoding) {
  return fs.readFile(file_path, { encoding });
}

async function write_file_text(file_path, content, encoding) {
  await fs.writeFile(file_path, content, { encoding });
}

function build_cli(command_name) {
  const chalk_instance = ensure_chalk();
  return yargs_factory(hide_process_argv(process.argv))
    .scriptName(command_name)
    .usage(
      "Usage: $0 [options] <file|glob ...>" +
        "\n\nDescription:" +
        "\n  Convert text files between zh-Hant (Traditional Chinese) and zh-Hans (Simplified Chinese)." +
        "\n  Default behavior writes converted content into sibling files with zh-Hans/zh-Hant suffixes.",
    )
    .option("to-hant", {
      type: "boolean",
      default: false,
      describe: "Convert to zh-Hant (Traditional). Default converts to zh-Hans (Simplified).",
    })
    .option("dry-run", {
      type: "boolean",
      default: false,
      describe: "Preview changes without writing files.",
    })
    .option("stdout", {
      type: "boolean",
      default: false,
      describe: "Print converted content to STDOUT (implies --dry-run).",
    })
    .option("replace", {
      type: "boolean",
      default: false,
      describe:
        "Overwrite input files instead of writing sibling files with zh-Hans/zh-Hant suffixes.",
    })
    .option("encoding", {
      type: "string",
      default: "utf8",
      describe: "Text encoding used for reading and writing files.",
    })
    .option("quiet", {
      type: "boolean",
      default: false,
      describe: "Suppress per-file logs (summary still shown).",
    })
    .example(
      `$0 a/b/*.txt c/*.md`,
      "Create zh-Hans copies (default) for all matched files.",
    )
    .example(
      `$0 --to-hant input/*.md`,
      "Convert text to zh-Hant (Traditional).",
    )
    .example(
      `$0 --stdout \"notes with spaces/*.txt\"`,
      "Preview Simplified conversion for quoted paths containing spaces.",
    )
    .example(
      `$0 --replace notes/**/*.md`,
      "Convert in place and overwrite originals.",
    )
    .help("help")
    .alias("h", "help")
    .alias("v", "version")
    .wrap(Math.min(120, process.stdout.columns || 120))
    .epilog(
      chalk_instance.dim("Examples support shell globs; remember to quote paths with spaces."),
    )
    .strict();
}

function build_output_path(file_path, convert_to_hant) {
  const parsed_path = path.parse(file_path);
  const variant_suffix = convert_to_hant ? "zh-Hant" : "zh-Hans";
  const sibling_name = `${parsed_path.name}.${variant_suffix}${parsed_path.ext}`;
  return path.join(parsed_path.dir, sibling_name);
}

async function ensure_output_is_safe(target_path) {
  try {
    await fs.stat(target_path);
    const target_relative = path.relative(process.cwd(), target_path);
    throw new Error(
      `Refusing to overwrite existing target file: ${target_relative}. Remove it or rerun with --replace to overwrite originals.`,
    );
  } catch (error) {
    if (error.code === "ENOENT") {
      return;
    }
    throw new Error(`Unable to verify target file: ${error.message}`);
  }
}

async function convert_file(file_path, options) {
  const { to_hant, dry_run, encoding, stdout, quiet, replace } = options;
  const chalk_instance = ensure_chalk();

  try {
    const original_text = await read_file_text(file_path, encoding);
    const converted_text = to_hant
      ? await convert_text_to_hant(original_text)
      : await convert_text_to_hans(original_text);

    if (converted_text === original_text) {
      if (!quiet) {
        console.log(
          chalk_instance.yellow(
            `No changes: ${path.relative(process.cwd(), file_path)}`,
          ),
        );
      }
      return { status: "unchanged" };
    }

    if (stdout) {
      process.stdout.write(
        `\n${chalk_instance.cyan.bold("==== ")}${chalk_instance.cyan(
          path.relative(process.cwd(), file_path),
        )}${chalk_instance.cyan.bold(" ====\n")}`,
      );
      process.stdout.write(converted_text);
      process.stdout.write("\n");
    }

    const output_path = replace
      ? file_path
      : build_output_path(file_path, to_hant);

    if (!replace && !dry_run && !stdout) {
      await ensure_output_is_safe(output_path);
    }

    if (!dry_run && !stdout) {
      await write_file_text(output_path, converted_text, encoding);
      if (!quiet) {
        console.log(
          chalk_instance.green(
            replace
              ? `Converted: ${path.relative(process.cwd(), file_path)}`
              : `Converted: ${path.relative(process.cwd(), file_path)} -> ${path.relative(
                  process.cwd(),
                  output_path,
                )}`,
          ),
        );
      }
    } else if (!quiet) {
      const preview_message = replace
        ? `Preview: ${path.relative(process.cwd(), file_path)}`
        : `Preview: ${path.relative(process.cwd(), file_path)} -> ${path.relative(
            process.cwd(),
            output_path,
          )}`;
      console.log(chalk_instance.blue(preview_message));
    }

    return { status: dry_run || stdout ? "preview" : "converted" };
  } catch (error) {
    console.error(
      chalk_instance.red(
        `Failed: ${path.relative(process.cwd(), file_path)} -> ${error.message}`,
      ),
    );
    return { status: "failed", error };
  }
}

async function main() {
  const command_name = path.basename(process.argv[1] || "zh_convert");
  const parser = build_cli(command_name);
  const argv = parser.parse();

  const chalk_instance = ensure_chalk();

  const input_patterns = argv._ || [];

  if (input_patterns.length === 0) {
    console.error(chalk_instance.red("Error: No input files provided."));
    parser.showHelp();
    process.exit(1);
    return;
  }

  const expanded_files = expand_patterns(input_patterns, {
    cwd: process.cwd(),
  });

  if (expanded_files.length === 0) {
    console.error(
      chalk_instance.red(
        "Error: No files matched the provided patterns (globs are supported).",
      ),
    );
    process.exit(2);
    return;
  }

  const to_hant = Boolean(argv["to-hant"]);
  const options = {
    to_hant,
    dry_run: Boolean(argv["dry-run"] || argv.stdout),
    stdout: Boolean(argv.stdout),
    encoding: argv.encoding,
    quiet: Boolean(argv.quiet),
    replace: Boolean(argv.replace),
  };

  const summary = {
    total: expanded_files.length,
    converted: 0,
    previewed: 0,
    unchanged: 0,
    failed: 0,
  };

  for (const file_path of expanded_files) {
    const result = await convert_file(file_path, options);
    if (result.status === "converted") {
      summary.converted += 1;
    } else if (result.status === "preview") {
      summary.previewed += 1;
    } else if (result.status === "unchanged") {
      summary.unchanged += 1;
    } else if (result.status === "failed") {
      summary.failed += 1;
    }
  }

  console.log("");
  console.log(chalk_instance.bold("Summary"));
  console.log(
    `${chalk_instance.white("Total:")} ${summary.total} | ${chalk_instance.green(
      "Converted:",
    )} ${summary.converted} | ${chalk_instance.blue("Previewed:")} ${summary.previewed} | ${chalk_instance.yellow(
      "Unchanged:",
    )} ${summary.unchanged} | ${chalk_instance.red("Failed:")} ${summary.failed}`,
  );

  if (summary.failed > 0) {
    process.exitCode = 1;
  }
}

if (require.main === module) {
  main().catch((error) => {
    const chalk_instance = ensure_chalk();
    console.error(chalk_instance.red(`Fatal error: ${error.message}`));
    process.exit(1);
  });
}

module.exports = {
  convert_text_to_hans,
  convert_text_to_hant,
  convert_file,
};
